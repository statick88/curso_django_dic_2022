[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Django 2023",
    "section": "",
    "text": "Curso de Django"
  },
  {
    "objectID": "index.html#qué-es-este-curso",
    "href": "index.html#qué-es-este-curso",
    "title": "Django 2023",
    "section": "¿Qué es este Curso?",
    "text": "¿Qué es este Curso?"
  },
  {
    "objectID": "index.html#a-quién-está-dirigido",
    "href": "index.html#a-quién-está-dirigido",
    "title": "Django 2023",
    "section": "¿A quién está dirigido?",
    "text": "¿A quién está dirigido?"
  },
  {
    "objectID": "index.html#cómo-contribuir",
    "href": "index.html#cómo-contribuir",
    "title": "Django 2023",
    "section": "¿Cómo contribuir?",
    "text": "¿Cómo contribuir?"
  },
  {
    "objectID": "unidades/unidad0/unidad0.html",
    "href": "unidades/unidad0/unidad0.html",
    "title": "Módulo 0: Git/Github",
    "section": "",
    "text": "Ejercicio práctico:"
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#introducción-a-git-y-control-de-versiones.",
    "href": "unidades/unidad0/unidad0.html#introducción-a-git-y-control-de-versiones.",
    "title": "Módulo 0: Git/Github",
    "section": "Introducción a Git y Control de Versiones.",
    "text": "Introducción a Git y Control de Versiones.\nGit es un sistema de control de versiones distribuido que permite rastrear cambios en el código de forma eficiente.\nEl control de versiones es esencial para mantener un historial de los cambios realizados en un proyecto y facilitar la colaboración en equipo."
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#configuración-de-un-repositorio-en-github",
    "href": "unidades/unidad0/unidad0.html#configuración-de-un-repositorio-en-github",
    "title": "Módulo 0: Git/Github",
    "section": "Configuración de un Repositorio en GitHub",
    "text": "Configuración de un Repositorio en GitHub\nGitHub es una plataforma de alojamiento de repositorios Git en la nube.\nCrea una cuenta en GitHub si no tienes una.\nPara configurar un nuevo repositorio en GitHub, sigue las instrucciones en la página web."
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#uso-básico-de-comandos-de-git.",
    "href": "unidades/unidad0/unidad0.html#uso-básico-de-comandos-de-git.",
    "title": "Módulo 0: Git/Github",
    "section": "Uso Básico de Comandos de Git.",
    "text": "Uso Básico de Comandos de Git.\nFlujo básico de git.\n\nEn la imágen anterior se describe el proceso básico para pasar de Local a Stage, de Stage a Commit y de Commit a Github y/o Cloud.\nClonar un repositorio existente desde GitHub a tu máquina local:\ngit clone url_repositorio\nCrear una nueva rama para trabajar en una funcionalidad específica:\ngit checkout -b nombre_rama\nHacer commits para guardar los cambios realizados:\ngit add archivo_modificado.py\ngit commit -m \"Mensaje del commit\"\nFusionar Ramas y Resolución de Conflictos\nCambiar a la rama principal:\ngit checkout main\nFusionar una rama con la rama principal:\ngit merge nombre_rama\nResolver conflictos que puedan surgir durante la fusión."
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#colaboración-en-un-proyecto-utilizando-github",
    "href": "unidades/unidad0/unidad0.html#colaboración-en-un-proyecto-utilizando-github",
    "title": "Módulo 0: Git/Github",
    "section": "Colaboración en un Proyecto Utilizando GitHub",
    "text": "Colaboración en un Proyecto Utilizando GitHub\nPara colaborar en un proyecto en GitHub, realiza lo siguiente:\nHaz un Fork del repositorio original en tu cuenta de GitHub.\nClona tu Fork a tu máquina local.\nCrea una nueva rama para realizar tus cambios.\nHace commits en tu rama.\nEnvía un Pull Request al repositorio original para que los colaboradores revisen tus cambios y los fusionen."
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#configurar-un-repositorio-y-realizar-cambios",
    "href": "unidades/unidad0/unidad0.html#configurar-un-repositorio-y-realizar-cambios",
    "title": "Módulo 0: Git/Github",
    "section": "Configurar un Repositorio y Realizar Cambios",
    "text": "Configurar un Repositorio y Realizar Cambios\n\nCrea un nuevo repositorio en GitHub.\nClona el repositorio a tu máquina local con el comando git clone url_repositorio.\nCrea una nueva rama con el comando git checkout -b nombre_rama.\nRealiza cambios en tus archivos y haz commits con git add y git commit.\nCambia a la rama principal con git checkout main.\nFusiona tu rama con la rama principal con git merge nombre_rama.\nEnvía tus cambios al repositorio en GitHub con git push origin main.\n\n¡Excelente! Ahora has aprendido los conceptos básicos de Git y GitHub, así como cómo configurar un repositorio y colaborar en un proyecto utilizando esta plataforma. En los próximos módulos, abordaremos el desarrollo web con Django."
  },
  {
    "objectID": "unidades/unidad0/unidad0.html#resolución-del-ejercicio-práctico",
    "href": "unidades/unidad0/unidad0.html#resolución-del-ejercicio-práctico",
    "title": "Módulo 0: Git/Github",
    "section": "Resolución del Ejercicio Práctico",
    "text": "Resolución del Ejercicio Práctico\nConfigurar un Repositorio y Realizar Cambios en el Proyecto Blog\nEn este ejercicio, configuraremos un repositorio Git para el proyecto del blog que vamos a dearrollar en los módulos 1 al 4. Luego, haremos algunos cambios en el proyecto y realizaremos commits para registrar esos cambios en el historial de versiones.\nPaso 1: Configurar el repositorio en GitHub\nAbre tu cuenta de GitHub y haz clic en el botón “New” para crear un nuevo repositorio.\nAsigna un nombre al repositorio y configura la visibilidad como desees.\nOpcionalmente, puedes agregar una descripción y una licencia.\nHaz clic en “Create repository” para crear el repositorio en GitHub.\nPaso 2: Clonar el repositorio en tu máquina local\nCopia la URL del repositorio que acabas de crear en GitHub (se verá como https://github.com/tu_usuario/nombre_repositorio.git).\nAbre una terminal o línea de comandos en la carpeta donde deseas clonar el repositorio.\nUtiliza el siguiente comando para clonar el repositorio en tu máquina local:\ngit clone url_repositorio\nReemplaza “url_repositorio” con la URL que copiaste en el paso 1.\nPaso 3: Realizar cambios en el proyecto del blog\nAbre el proyecto del blog en tu editor de código o IDE favorito.\nRealiza algunos cambios en los archivos de tu proyecto, como agregar nuevas funcionalidades, modificar plantillas o corregir errores.\nPaso 4: Hacer commits para registrar los cambios\nDespués de hacer cambios en el proyecto, utiliza los siguientes comandos para hacer commit y registrar esos cambios en el historial de versiones:\ngit add .\ngit commit -m \"Mensaje descriptivo del commit\"\nEl comando git add . agrega todos los cambios realizados en los archivos del proyecto al área de preparación, y el comando git commit -m “Mensaje” crea un nuevo commit con un mensaje descriptivo para los cambios realizados.\nPaso 5: Enviar los cambios al repositorio en GitHub\nDespués de hacer commit de los cambios en tu repositorio local, utiliza el siguiente comando para enviar los cambios al repositorio en GitHub:\ngit push origin main` \nReemplaza “main” con el nombre de la rama principal de tu proyecto si utilizas otro nombre diferente.\n¡Felicitaciones! Ahora has configurado un repositorio Git para tu proyecto y has realizado cambios en el proyecto, registrando esos cambios mediante commits.\nLos cambios ahora están disponibles en el repositorio en GitHub. Puedes repetir estos pasos cada vez que desees realizar cambios en el proyecto y mantener un historial de versiones de tu proyecto en GitHub."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html",
    "href": "unidades/unidad1/unidad1.html",
    "title": "Módulo 1: Introducción a Django.",
    "section": "",
    "text": "Ejemplo Práctico:"
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#qué-es-django-y-por-qué-utilizarlo",
    "href": "unidades/unidad1/unidad1.html#qué-es-django-y-por-qué-utilizarlo",
    "title": "Módulo 1: Introducción a Django.",
    "section": "¿Qué es Django y por qué utilizarlo?",
    "text": "¿Qué es Django y por qué utilizarlo?\n\nDjango es un framework web de alto nivel basado en Python.\nFacilita el desarrollo rápido de aplicaciones web robustas y seguras.\nVentajas de Django: MVC (Modelo-Vista-Controlador), administrador de base de datos, seguridad integrada y comunidad activa."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#mvc-vs-mtv.",
    "href": "unidades/unidad1/unidad1.html#mvc-vs-mtv.",
    "title": "Módulo 1: Introducción a Django.",
    "section": "MVC vs MTV.",
    "text": "MVC vs MTV."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#instalación-de-django-4.2.3-y-configuración-del-entorno-de-desarrollo",
    "href": "unidades/unidad1/unidad1.html#instalación-de-django-4.2.3-y-configuración-del-entorno-de-desarrollo",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Instalación de Django 4.2.3 y Configuración del Entorno de Desarrollo",
    "text": "Instalación de Django 4.2.3 y Configuración del Entorno de Desarrollo\nPara instalar Django 4.2.3, se recomienda utilizar un entorno virtual (por ejemplo, con virtualenv o conda).\nComandos para instalar Django y crear un entorno virtual:\nInstalación de virtualenv\npip install virtualenv\nCreación del entorno virtual\npython -m venv env\nActivación del Entorno Virtual\ncd env/Scripts\nactivate\nSalir del directorio Scripts\ncd ../../\nInstalación de Django usando pip\npip install django==4.2.3"
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#creación-de-un-proyecto-en-django.",
    "href": "unidades/unidad1/unidad1.html#creación-de-un-proyecto-en-django.",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Creación de un Proyecto en Django.",
    "text": "Creación de un Proyecto en Django.\nPara crear un nuevo proyecto Django, utilizamos el comando\ndjango-admin startproject nombre_proyecto ."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#creación-de-una-aplicación-en-django",
    "href": "unidades/unidad1/unidad1.html#creación-de-una-aplicación-en-django",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Creación de una Aplicación en Django",
    "text": "Creación de una Aplicación en Django\nUna aplicación es un componente reutilizable de un proyecto Django. Comando para crear una nueva aplicación:\npython manage.py startapp nombre_app\nEstructura de directorios de una aplicación:\nnombre_app/\n│   migrations/\n│   │   ...\n│   │   __init__.py\n│   │\n│   │   admin.py\n│   │   apps.py\n│   │   models.py\n│   │   tests.py\n│   │   views.py\n\nnombre_app/: Es el directorio raíz de la aplicación. Contiene archivos esenciales y directorios para el funcionamiento de la aplicación.\nmigrations/: Este directorio es generado automáticamente por Django cuando se realizan cambios en los modelos de la aplicación. Contiene archivos de migración que representan los cambios en la base de datos.\ninit.py: Este archivo indica a Python que el directorio es un paquete y permite la importación de módulos dentro de él.\nadmin.py: En este archivo se pueden registrar los modelos de la aplicación para que aparezcan en el panel de administración de Django.\napps.py: Es el archivo donde se define la configuración de la aplicación, como su nombre y configuraciones adicionales.\nmodels.py: Aquí se definen los modelos de la aplicación utilizando la clase “Model” de Django. Los modelos representan las tablas en la base de datos y definen los campos y relaciones de la aplicación.\ntests.py: Es el archivo donde se pueden escribir pruebas unitarias y de integración para la aplicación.\nviews.py: Contiene las vistas de la aplicación, que son funciones o clases que manejan las solicitudes y generan las respuestas. Las vistas determinan qué se muestra en las páginas web de la aplicación."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#creación-de-un-proyecto-de-e-commerce-en-django",
    "href": "unidades/unidad1/unidad1.html#creación-de-un-proyecto-de-e-commerce-en-django",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Creación de un Proyecto de E-commerce en Django",
    "text": "Creación de un Proyecto de E-commerce en Django\nEn esta actividad práctica, crearás un nuevo proyecto de e-commerce en Django desde cero. Asegúrate de tener Django instalado en tu entorno de desarrollo antes de comenzar.\nPaso 1: Crear un Proyecto de Django\nAbre una terminal o línea de comandos en la ubicación donde desees crear tu proyecto de e-commerce.\nEjecuta el siguiente comando para crear un nuevo proyecto Django llamado “mi_ecommerce”:\ndjango-admin startproject mi_ecommerce\nVerás que se ha creado un nuevo directorio llamado “mi_ecommerce” que contiene la estructura inicial del proyecto.\nPaso 2: Crear una Aplicación para el E-commerce\nCambia al directorio recién creado “mi_ecommerce”:\ncd mi_ecommerce\nAhora, crea una nueva aplicación llamada “ecommerce” utilizando el siguiente comando:\npython manage.py startapp ecommerce\nSe creará un nuevo directorio “ecommerce” dentro de tu proyecto, que contendrá todos los archivos necesarios para la aplicación.\nPaso 3: Configurar el Proyecto y la Aplicación\nAbre el archivo “settings.py” ubicado en el directorio “mi_ecommerce/mi_ecommerce”.\nAsegúrate de agregar la aplicación “ecommerce” en la lista de “INSTALLED_APPS” para que Django la reconozca:\nINSTALLED_APPS = [\n    # Otras aplicaciones...\n    'ecommerce',\n]\nPaso 4: Ejecutar el Servidor de Desarrollo\nAhora, ejecuta el servidor de desarrollo para ver el proyecto en acción:\npython manage.py runserver\nAbre tu navegador y visita la dirección “http://localhost:8000/”. Deberías ver la página de bienvenida de Django.\nSi has llegado a este punto, ¡Felicidades! Has creado con éxito un nuevo proyecto de e-commerce en Django y una aplicación llamada “ecommerce”. Ahora puedes comenzar a desarrollar las funcionalidades del e-commerce y diseñar las diapositivas para cada uno de los módulos del curso.\n\n¡Buena suerte!"
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#creación-de-un-blog",
    "href": "unidades/unidad1/unidad1.html#creación-de-un-blog",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Creación de Un Blog",
    "text": "Creación de Un Blog\nEn esta actividad práctica, crearás un nuevo proyecto de Blog en Django desde cero. Asegúrate de tener Django instalado en tu entorno de desarrollo antes de comenzar.\n\nIniciar un Repositorio\nCrear el entorno virtual\nActivación del entorno virtual\nInstalación de Django\nCrear el archivo requirements.txt\nAgregar el archivo .gitignore\nCrear un Proyecto con Django\nCrear la App dentro del Proyecto\nAgregar la App al Archivo settings.py del Proyecto\nCorrer el Servidor de Pruebas"
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#resolución-de-la-actividad-práctica",
    "href": "unidades/unidad1/unidad1.html#resolución-de-la-actividad-práctica",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Resolución de la Actividad Práctica:",
    "text": "Resolución de la Actividad Práctica:\nPara crear el proyecto de Blog en Django y completar las actividades prácticas, sigue los siguientes pasos:\nPaso 1: Iniciar un Repositorio\nInicia un nuevo repositorio en tu sistema de control de versiones (por ejemplo, en GitHub) para gestionar el código de tu proyecto.\nPaso 2: Crear el Entorno Virtual\nCrea un nuevo entorno virtual para aislar las dependencias del proyecto y evitar conflictos con otras aplicaciones Python instaladas en tu sistema.\n# Ejecutar en la terminal o consola\npython -m venv mi_entorno_virtual\nPaso 3: Activación del Entorno Virtual\nActiva el entorno virtual antes de instalar Django o trabajar en el proyecto.\n# En Windows\nmi_entorno_virtual\\Scripts\\activate\n\n# En macOS o Linux\nsource mi_entorno_virtual/bin/activate\nPaso 4: Instalación de Django\nDentro del entorno virtual, instala Django utilizando pip.\n# Ejecutar en la terminal o consola\npip install django\nPaso 5: Crear el Archivo requirements.txt\nCrea un archivo “requirements.txt” en la raíz del proyecto para almacenar todas las dependencias de Python utilizadas en el proyecto.\n# requirements.txt\nDjango==4.2.3\nPaso 6: Agregar el Archivo .gitignore\nCrea un archivo “.gitignore” en la raíz del proyecto para evitar que los archivos y directorios innecesarios se incluyan en el repositorio.\n# .gitignore\nmi_entorno_virtual/\n__pycache__/\n*.pyc\ndb.sqlite3\nPaso 7: Crear un Proyecto con Django\nCrea un nuevo proyecto de Django llamado “mi_blog”.\n# Ejecutar en la terminal o consola\ndjango-admin startproject mi_blog\nPaso 8: Crear la App dentro del Proyecto\nCrea una nueva aplicación llamada “blog” dentro del proyecto “mi_blog”.\n# Ejecutar en la terminal o consola\ncd mi_blog\npython manage.py startapp blog\nPaso 9: Agregar la App al Archivo settings.py del Proyecto\nAbre el archivo “settings.py” en la carpeta “mi_blog” y agrega la aplicación “blog” a la lista de aplicaciones instaladas.\n# settings.py\n\nINSTALLED_APPS = [\n    ...\n    'blog',\n]\nPaso 10: Correr el Servidor de Pruebas\nPara verificar que todo está configurado correctamente, inicia el servidor de pruebas de Django.\n# Ejecutar en la terminal o consola\npython manage.py runserver\nAhora podrás acceder a la página de inicio de Django en tu navegador web en la dirección “http://127.0.0.1:8000/”.\nCon estos pasos, has creado un nuevo proyecto de Blog en Django, configurado un entorno virtual, instalado Django y creado una nueva aplicación dentro del proyecto. Ahora estás listo para comenzar a desarrollar tu blog utilizando Django."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html",
    "href": "unidades/unidad2/unidad2.html",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "",
    "text": "Ejemplo Práctico:"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#diseño-de-modelos-en-django",
    "href": "unidades/unidad2/unidad2.html#diseño-de-modelos-en-django",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Diseño de Modelos en Django",
    "text": "Diseño de Modelos en Django\nEn este diagrama, se muestra el flujo de diseño de modelos en Django.\n\n         +-----------------------+\n         |                       |\n         | Definir el modelo     |\n         | como una clase        |\n         | Python que hereda de  |\n         | models.Model          |\n         |                       |\n         +----+-------------+----+\n              |             |\n              |             |\n              v             v\n  +-------------------+   +------------------+\n  |                   |   |                  |\n  | Definir campos    |   | Definir métodos  |\n  | y atributos       |   | adicionales      |\n  | del modelo        |   | del modelo       |\n  |                   |   |                  |\n  +--------+----------+   +------+-----------+\n           |                     |\n           |                     |\n           v                     v\n+--------------------+   +--------------------+\n|                    |   |                    |\n| Aplicar migraciones|   | Definir __str__    |\n| para reflejar los  |   | método para        |\n| cambios en la      |   | representación     |\n| base de datos      |   | del modelo         |\n|                    |   |                    |\n+--------------------+   +--------------------+"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#definimos-el-modelo.",
    "href": "unidades/unidad2/unidad2.html#definimos-el-modelo.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "1. Definimos el Modelo.",
    "text": "1. Definimos el Modelo.\nEn Django, los modelos son la base para diseñar la estructura de la base de datos de nuestra aplicación web.\nCada modelo representa una tabla en la base de datos y define los campos que estarán presentes en dicha tabla.\nLos modelos son definidos como clases Python que heredan de models.Model, lo que permite que Django maneje automáticamente la creación y gestión de la base de datos.\n\nCreación de un Modelo.\nPara crear un modelo en Django, primero definimos una clase Python que representa la tabla en la base de datos. Por ejemplo, si deseamos crear un modelo para representar las publicaciones en nuestro blog, podemos definirlo de la siguiente manera:\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=200)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField()\nEn este ejemplo, hemos definido el modelo Publicacion con tres campos: titulo, contenido y fecha_publicacion.\nCada campo se representa mediante un atributo de la clase, donde: models.CharField representa un campo de texto, models.TextField representa un campo de texto más largo y models.DateTimeField representa una fecha y hora."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#definir-métodos-del-modelo.",
    "href": "unidades/unidad2/unidad2.html#definir-métodos-del-modelo.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "2. Definir Métodos del Modelo.",
    "text": "2. Definir Métodos del Modelo.\nAdemás de los campos, también podemos definir métodos en el modelo para realizar acciones específicas o para dar formato a los datos. Por ejemplo, podríamos agregar un método que nos devuelva una representación más legible de la publicación:\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=200)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField()\n\n    def __str__(self):\n        return self.titulo\nEn este caso, hemos definido el método str que se ejecutará cuando necesitemos obtener una representación de texto del objeto Publicacion.\nEn este caso, hemos decidido que la representación será simplemente el título de la publicación.\nPara poder probar los cambios que hemos realizado vamos a registrar nuestro modelo en el archivo admin.py\n#  admin.py\n\nfrom .models import Publicacion\n\nadmin.site.register(Publicacion)"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#aplicar-migraciones.",
    "href": "unidades/unidad2/unidad2.html#aplicar-migraciones.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "3. Aplicar Migraciones.",
    "text": "3. Aplicar Migraciones.\nUna vez que hemos definido nuestro modelo, necesitamos aplicar las migraciones para que los cambios se reflejen en la base de datos.\n# Ejecutar en la terminal o consola\npython manage.py makemigrations\npython manage.py migrate\nCon estos pasos, hemos diseñado nuestro modelo de Publicaciones en Django y aplicado las migraciones para crear la tabla correspondiente en la base de datos. Ahora estamos listos para utilizar nuestro modelo y almacenar datos en la base de datos.\nFinalmente creamos un superusuario para acceder a la administración de nuestro proyecto.\npython manage.py createsuperuser\nLlenamos un pequeño formulario que nos pide: nombre de usuario, correo electrónico (no obligatorio), password, repeat again password.\nY listo para poder acceder a la administración de nuestro proyecto nos dirigimos a la siguiente url http://127.0.0.1:8000/admin\nDe forma gráfica ingresamos nuestro usuario y contraseña creado."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#ejemplo-de-las-clases-publicación-y-comentario-en-django",
    "href": "unidades/unidad2/unidad2.html#ejemplo-de-las-clases-publicación-y-comentario-en-django",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Ejemplo de las clases Publicación y Comentario en Django:",
    "text": "Ejemplo de las clases Publicación y Comentario en Django:\n# En el archivo models.py de la aplicación \"Publicaciones\"\n\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    pub_date = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.title\n\nclass Comentario(models.Model):\n    publicacion = models.ForeignKey(Publicacion, on_delete=models.CASCADE)\n    author = models.CharField(max_length=50)\n    content = models.TextField()\n    pub_date = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return f\"Comentario de {self.author} en {self.publicacion}\"\nEn este ejemplo, hemos definido dos clases:\nLa clase “Publicacion”: Representa una publicación en el blog y tiene tres campos: title (título de la publicación), content (contenido de la publicación) y pub_date (fecha de publicación).\nLa fecha de publicación se establece automáticamente utilizando la función auto_now_add=True.\nTambién hemos definido un método “str” para que al imprimir una instancia de la clase, se muestre el título de la publicación.\nLa clase “Comentario”: Representa un comentario en una publicación de publicacion específica y tiene cuatro campos: publicacion (clave externa que se relaciona con la publicacion al que pertenece el comentario), author (nombre del autor del comentario), content (contenido del comentario) y pub_date (fecha de publicación del comentario).\nAl igual que en la clase Publicacion, hemos definido un método “str” para mostrar información útil al imprimir una instancia de la clase."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#migraciones-de-la-base-de-datos",
    "href": "unidades/unidad2/unidad2.html#migraciones-de-la-base-de-datos",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Migraciones de la Base de Datos",
    "text": "Migraciones de la Base de Datos\nLas migraciones en Django son una forma de gestionar los cambios en la estructura de la base de datos de manera controlada y consistente.\nRepresentan los cambios en la estructura de la base de datos en forma de archivos Python y se utilizan para crear, modificar o eliminar tablas y campos.\nCuando definimos nuestros modelos en Django (como se mostró en el ejemplo de la clase “Publicación” y “Comentario”), estamos describiendo la estructura de nuestras tablas en la base de datos.\nSin embargo, antes de que estos modelos se puedan utilizar, Django necesita traducirlos en el lenguaje específico del motor de base de datos que estamos utilizando (por ejemplo, PostgreSQL, MySQL, SQLite, etc.).\nEs aquí donde entran en juego las migraciones.\nCuando creamos o modificamos modelos, Django genera automáticamente archivos de migración que contienen instrucciones para aplicar los cambios necesarios en la base de datos. Cada migración representa un paso en la evolución de la estructura de la base de datos.\nComandos para crear y aplicar migraciones:\npython manage.py makemigrations\nEste comando se utiliza para crear una nueva migración a partir de los cambios detectados en los modelos. Cuando ejecutamos este comando, Django analiza los modelos definidos en nuestra aplicación y compara la estructura actual con la estructura de la última migración aplicada.\nLuego, genera una nueva migración que contiene las instrucciones para llevar la base de datos a su estado actual.\npython manage.py migrate\nUna vez que hemos creado una o varias migraciones, utilizamos este comando para aplicar esas migraciones pendientes y modificar la base de datos de acuerdo con los cambios en los modelos. Django realiza las operaciones necesarias en la base de datos para reflejar la estructura actual de los modelos definidos en nuestra aplicación.\n💡Recuerda: “Es importante ejecutar estos comandos cada vez que realizamos cambios en los modelos para mantener la coherencia entre la estructura de la base de datos y la estructura definida en los modelos, garantizando así la integridad y consistencia de nuestros datos.”"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#consultas-a-la-base-de-datos-con-el-orm-de-django.",
    "href": "unidades/unidad2/unidad2.html#consultas-a-la-base-de-datos-con-el-orm-de-django.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Consultas a la Base de Datos con el ORM de Django.",
    "text": "Consultas a la Base de Datos con el ORM de Django.\nCuando construimos aplicaciones web, a menudo necesitamos interactuar con una base de datos para almacenar y recuperar datos.\nDjango facilita esta tarea mediante su Object-Relational Mapping (ORM).\nPero, ¿Qué es exactamente el ORM y cómo podemos hacer consultas a la base de datos utilizando esta funcionalidad?\nObject-Relational Mapping (ORM): Una forma amigable de interactuar con la base de datos.\nImagina que tienes una biblioteca y quieres mantener un registro de los libros y sus autores en una base de datos. Tradicionalmente, tendrías que escribir consultas SQL para agregar, actualizar o recuperar información. Sin embargo, con el ORM de Django, puedes utilizar objetos de Python para realizar estas tareas sin tener que escribir consultas SQL directamente. ¡Es como si el ORM tradujera automáticamente tus interacciones con objetos de Python a instrucciones SQL!"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#ejemplo-de-consulta-con-el-orm-de-django",
    "href": "unidades/unidad2/unidad2.html#ejemplo-de-consulta-con-el-orm-de-django",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Ejemplo de Consulta con el ORM de Django",
    "text": "Ejemplo de Consulta con el ORM de Django\nSupongamos que tienes dos modelos en Django: Publicacion con los campos titulo, contenido y fecha_publicacion, y Comentario con los campos texto y fecha_comentario.\nQueremos obtener todas las publicaciones que contengan comentarios y mostrar sus títulos, fechas de publicación y la cantidad de comentarios que tienen.\nfrom miapp.models import Publicacion, Comentario\n\n# Realizamos una consulta utilizando el ORM de Django\npublicaciones_con_comentarios = Publicacion.objects.filter(comentario__isnull=False)\n\n# Mostramos los resultados\nfor publicacion in publicaciones_con_comentarios:\n    cantidad_comentarios = Comentario.objects.filter(publicacion=publicacion).count()\n    print(f\"Título: {publicacion.titulo}, Fecha de Publicación: {publicacion.fecha_publicacion}, Comentarios: {cantidad_comentarios}\")\nEn este ejemplo, la función filter(comentario__isnull=False) nos permite obtener todas las publicaciones que tienen comentarios, es decir, filtramos aquellas publicaciones donde el campo comentario no es nulo.\nLuego, utilizamos un bucle for para recorrer los resultados y, para cada publicación, realizamos una nueva consulta para contar la cantidad de comentarios asociados a esa publicación utilizando Comentario.objects.filter(publicacion=publicacion).count().\nAsí, podemos mostrar los títulos de las publicaciones, sus fechas de publicación y la cantidad de comentarios que tienen."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#diagrama-de-consulta-con-orm-de-django.",
    "href": "unidades/unidad2/unidad2.html#diagrama-de-consulta-con-orm-de-django.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Diagrama de Consulta con ORM de Django.",
    "text": "Diagrama de Consulta con ORM de Django.\n                      +----------------+\n                      |  Base de Datos |\n                      +----------------+\n                            |\n                            v\n                      +----------------+\n                      |    Modelo     |\n                      |  (Publicacion) |\n                      +----------------+\n                            |\n                            v\n                      +----------------+\n                      |   Consulta    |\n                      |   (filter)    |\n                      +----------------+\n                            |\n                            v\n                      +----------------+\n                      |   Resultado   |\n                      +----------------+\nEn este diagrama, el modelo Publicacion representa la estructura de la tabla en la base de datos.\nLa consulta se realiza a través del ORM de Django, que traduce la interacción con el modelo en una consulta SQL y devuelve el resultado.\nEl ORM de Django nos permite realizar consultas de una manera más legible y amigable, lo que facilita enormemente el manejo de datos en nuestras aplicaciones web."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#relaciones-entre-modelos.",
    "href": "unidades/unidad2/unidad2.html#relaciones-entre-modelos.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Relaciones entre Modelos.",
    "text": "Relaciones entre Modelos.\n\n            +--------------------+          +--------------------+\n            |      Publicacion   |          |        Autor       |\n            +--------------------+          +--------------------+\n            | - id               |          | - id               |\n            | - titulo           |          | - nombre           |\n            | - contenido        |          | - correo           |\n            | - autor (foránea)  |          +--------------------+\n            +--------------------+\n                   |\n                   v\n            +--------------------+\n            |     Relación       |\n            |   (Clave Foránea)  |\n            +--------------------+\n                   |\n                   v\n            +--------------------+\n            |      Resultado     |\n            +--------------------+\nDjango facilita el establecimiento de relaciones entre modelos mediante claves foráneas y claves primarias.\nPor ejemplo,\nEn un blog, un modelo Publicacion podría tener una clave foránea a un modelo Autor”, lo que permitiría relacionar cada publicación con su respectivo autor.\nAdemás, Django también soporta diferentes tipos de relaciones como Uno a Uno (por ejemplo, un modelo Perfil asociado a un modelo Usuario), Uno a Muchos (por ejemplo, un modelo Categoría que puede tener múltiples publicaciones) y Muchos a Muchos (por ejemplo, una relación de Seguidores entre usuarios).\nEstas relaciones son fundamentales para organizar y acceder a los datos de manera estructurada en una aplicación Django."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#clave-primaria-clave-foránea-y-relaciones-entre-modelos-en-django.",
    "href": "unidades/unidad2/unidad2.html#clave-primaria-clave-foránea-y-relaciones-entre-modelos-en-django.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Clave Primaria, Clave Foránea y Relaciones entre Modelos en Django.",
    "text": "Clave Primaria, Clave Foránea y Relaciones entre Modelos en Django.\nEn Django, los modelos representan la estructura de las tablas en la base de datos. Cada modelo se define como una clase Python que hereda de models.Model. Los atributos de la clase representan los campos de la tabla, y entre ellos, destacamos las claves primarias y las claves foráneas."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#clave-primaria.",
    "href": "unidades/unidad2/unidad2.html#clave-primaria.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Clave Primaria.",
    "text": "Clave Primaria.\nEjemplo:\nfrom django.db import models\n\nclass Autor(models.Model):\n    nombre = models.CharField(max_length=100)\n    pais = models.CharField(max_length=50)\n\n    def __str__(self):\n        return self.nombre\nLa clave primaria es un campo único que identifica de forma exclusiva cada registro en una tabla.\nPor defecto, Django crea automáticamente un campo id como clave primaria para cada modelo, pero también es posible definir una clave primaria personalizada utilizando el atributo primary_key=True.\nEn este ejemplo, la tabla Autor tendrá una clave primaria id generada automáticamente. La columna id es un campo único que identificará de forma única a cada autor en la base de datos."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#clave-foránea.",
    "href": "unidades/unidad2/unidad2.html#clave-foránea.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Clave Foránea.",
    "text": "Clave Foránea.\nEjemplo:\nfrom django.db import models\n\nclass Libro(models.Model):\n    titulo = models.CharField(max_length=200)\n    autor = models.ForeignKey(Autor, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.titulo\nLa clave foránea es un campo que hace referencia a la clave primaria de otra tabla, estableciendo una relación entre ambas tablas.\nEsto indica que el valor del campo de la clave foránea en una tabla debe coincidir con el valor de la clave primaria en la otra tabla.\nEn este ejemplo, el modelo Libro tiene un campo autor que es una clave foránea que hace referencia al modelo Autor. Cada libro está relacionado con un autor específico, y la opción on_delete=models.CASCADE indica que si se elimina un autor, todos los libros asociados a ese autor también se eliminarán automáticamente."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#relaciones-entre-modelos-de-django",
    "href": "unidades/unidad2/unidad2.html#relaciones-entre-modelos-de-django",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Relaciones entre Modelos de Django:",
    "text": "Relaciones entre Modelos de Django:\nRelación de Uno a Muchos (OneToMany): Un objeto de un modelo está relacionado con varios objetos de otro modelo.\nSe logra utilizando el campo ForeignKey.\nfrom django.contrib.auth.models import User\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=100)\n    contenido = models.TextField()\n    autor = models.ForeignKey(User, on_delete=models.CASCADE)\nRelación de Muchos a Muchos (ManyToMany): Varios objetos de un modelo están relacionados con varios objetos de otro modelo. Se logra utilizando el campo ManyToManyField.\nfrom django.db import models\n\nclass Etiqueta(models.Model):\n    nombre = models.CharField(max_length=50)\n\nclass Producto(models.Model):\n    nombre = models.CharField(max_length=100)\n    etiquetas = models.ManyToManyField(Etiqueta)\nRelación de Uno a Uno (OneToOne): Un objeto de un modelo está relacionado con exactamente un objeto de otro modelo, y viceversa. Se logra utilizando el campo OneToOneField.\nfrom django.contrib.auth.models import User\nfrom django.db import models\n\nclass Perfil(models.Model):\n    usuario = models.OneToOneField(User, on_delete=models.CASCADE)\n    fecha_nacimiento = models.DateField()\nEstas relaciones nos permiten asociar objetos de diferentes modelos en la base de datos, lo que es esencial para construir aplicaciones web más complejas.\nDjango facilita el manejo de estas relaciones, lo que nos permite desarrollar aplicaciones de forma más legible y amigable.\nDjango ofrece una potente forma de establecer relaciones entre modelos, lo que nos permite diseñar y construir aplicaciones web más complejas y ricas en datos.\nLa elección del tipo de relación dependerá de la lógica de negocio y los requerimientos específicos de la aplicación."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#ejemplo-de-conexión-del-proyecto-blog-con-bases-de-datos",
    "href": "unidades/unidad2/unidad2.html#ejemplo-de-conexión-del-proyecto-blog-con-bases-de-datos",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Ejemplo de Conexión del Proyecto Blog con Bases de Datos",
    "text": "Ejemplo de Conexión del Proyecto Blog con Bases de Datos\nA continuación, se presentará un ejemplo de configuración de Django para conectar el proyecto de blog a tres bases de datos diferentes: SQLite, MySQL, MongoDB y PostgreSQL."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#sqlite",
    "href": "unidades/unidad2/unidad2.html#sqlite",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "SQLite:",
    "text": "SQLite:\nSQLite es una base de datos incorporada en Django por defecto. No requiere configuración adicional para usarla, ya que Django creará automáticamente un archivo de base de datos SQLite en el directorio del proyecto.\n# En el archivo settings.py del proyecto \"mi_blog\"\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}"
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#mysql",
    "href": "unidades/unidad2/unidad2.html#mysql",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "MySQL:",
    "text": "MySQL:\nPara conectar la base de datos de MySQL de forma local en tu máquina, necesitarás seguir estos pasos:\n\nInstalar MySQL Server: Lo primero que necesitas es tener instalado el servidor de MySQL en tu máquina. Puedes descargar la versión correspondiente para tu sistema operativo desde el sitio web oficial de MySQL: https://dev.mysql.com/downloads/mysql/\nConfigurar el servidor: Una vez que hayas instalado MySQL, debes configurar el servidor.\nDurante la instalación, se te pedirá establecer una contraseña para el usuario “root” que será el administrador del servidor.\nAsegúrate de recordar esta contraseña, ya que la necesitarás más adelante.\nIniciar el servidor: Después de instalar y configurar MySQL, debes iniciar el servidor.\nEsto puede variar dependiendo de tu sistema operativo, pero generalmente puedes hacerlo desde la línea de comandos o utilizando un programa específico para administrar servidores de bases de datos.\nVerificar la conexión: Una vez que el servidor esté en funcionamiento, verifica que puedas conectarte a él.\nPuedes hacerlo desde la línea de comandos utilizando el cliente de MySQL o usando una herramienta de administración como phpMyAdmin.\nCrear una base de datos: Antes de conectar Django a la base de datos, necesitas crear una base de datos vacía para tu proyecto.\nPuedes hacerlo desde el cliente de MySQL o desde una herramienta de administración.\nConfigurar Django para usar MySQL: Ahora que tienes el servidor de MySQL funcionando y una base de datos creada, puedes configurar Django para que utilice MySQL como base de datos, puedes instalar el cliente de MySQL MySQL Workbench.\nAhora es necesario instalar el connector entre Django y nuestra base de datos, lo podemos hacer con el gestor de paquetes pip\n\npip install mysqlclient\nAhora vamos a configurar Django.\n\nPara hacerlo, modifica el archivo settings.py de tu proyecto Django y ajusta la configuración de la base de datos:\n# settings.py\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'nombre_de_la_base_de_datos',\n        'USER': 'nombre_de_usuario',\n        'PASSWORD': 'contraseña_del_usuario',\n        'HOST': 'localhost',\n        'PORT': '3306',\n    }\n}\nAsegúrate de reemplazar nombre_de_la_base_de_datos, nombre_de_usuario y contraseña_del_usuario con los valores adecuados para tu configuración de MySQL.\n\nRealizar migraciones: Una vez configurada la base de datos en Django, es necesario aplicar las migraciones para crear las tablas y campos correspondientes. Ejecuta el siguiente comando para aplicar las migraciones:\n\npython manage.py migrate\n\nVerificar la conexión: Finalmente, verifica que la conexión con la base de datos de MySQL se haya establecido correctamente y que puedas realizar consultas y operaciones desde tu proyecto Django.\nCon estos pasos, tendrás configurada la conexión con la base de datos de MySQL en tu proyecto de Django y podrás utilizarla para almacenar y recuperar datos de forma local en tu máquina."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#postgresql",
    "href": "unidades/unidad2/unidad2.html#postgresql",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "PostgreSQL:",
    "text": "PostgreSQL:\nLo primero que necesitas es instalar PostgreSQL en tu sistema operativo.\nPuedes descargar la versión correspondiente para tu sistema desde el sitio web oficial de PostgreSQL: https://www.postgresql.org/download/\n\nConfigurar PostgreSQL: Durante la instalación, se te pedirá establecer una contraseña para el usuario “postgres” que será el administrador del servidor PostgreSQL. Asegúrate de recordar esta contraseña, ya que la necesitarás más adelante.\nIniciar el servidor PostgreSQL: Después de instalar PostgreSQL, debes iniciar el servidor. Esto puede variar dependiendo de tu sistema operativo, pero generalmente puedes hacerlo desde la línea de comandos o utilizando una herramienta específica para administrar servidores de bases de datos.\nVerificar la conexión: Una vez que el servidor esté en funcionamiento, verifica que puedas conectarte a él. Puedes hacerlo desde la línea de comandos utilizando el cliente psql o usando una herramienta de administración gráfica como pgAdmin.\nInstalar el controlador de PostgreSQL para Django: Para conectar Django con PostgreSQL, necesitas instalar el controlador psycopg2. Puedes instalarlo utilizando el gestor de paquetes pip:\npip install psycopg2 \nConfigurar Django para usar PostgreSQL:\nModifica el archivo settings.py de tu proyecto Django y ajusta la configuración de la base de datos:\n\n# settings.py\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'nombre_de_la_base_de_datos',\n        'USER': 'nombre_de_usuario',\n        'PASSWORD': 'contraseña_del_usuario',\n        'HOST': 'localhost',  # Puedes cambiar esta dirección si PostgreSQL está en otro equipo\n        'PORT': '',          # Por defecto es el puerto 5432\n    }\n}\nAsegúrate de reemplazar nombre_de_la_base_de_datos, nombre_de_usuario y contraseña_del_usuario con los valores adecuados para tu configuración de PostgreSQL.\n\nRealizar migraciones:\nUna vez configurada la base de datos en Django, es necesario aplicar las migraciones para crear las tablas y campos correspondientes. Ejecuta el siguiente comando para aplicar las migraciones:\n\npython manage.py migrate \n\nVerificar la conexión:\n\nFinalmente, verifica que la conexión con PostgreSQL se haya establecido correctamente y que puedas realizar consultas y operaciones desde tu proyecto Django.\nCon estos pasos, tendrás configurada la conexión con PostgreSQL en tu proyecto de Django y podrás utilizarla para almacenar y recuperar datos.\nPostgreSQL es una base de datos relacional que ofrece características avanzadas y es ampliamente utilizada en aplicaciones web y proyectos de desarrollo."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#mongodb",
    "href": "unidades/unidad2/unidad2.html#mongodb",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "MongoDB:",
    "text": "MongoDB:\n\nLo primero que necesitas es instalar MongoDB en tu sistema operativo. Puedes descargar la versión correspondiente para tu sistema desde el sitio web oficial de MongoDB: https://www.mongodb.com/try/download/community\nConfigurar el servidor MongoDB: Una vez que hayas instalado MongoDB, es necesario configurar el servidor.\nPor defecto, MongoDB se ejecuta en el puerto 27017. Asegúrate de que el servidor MongoDB esté en funcionamiento antes de continuar.\nInstalar el controlador de MongoDB para Django: Para conectar Django con MongoDB, necesitas instalar el controlador de MongoDB para Django, llamado “djongo”. Puedes instalarlo utilizando el gestor de paquetes pip:\npip install djongo==1.3.1\nPara que todo funcione con normalidad, es necesario incluir el paquete pymongo, para ello se sugiere utilizar el siguiente comando.\npip install pymongo==3.12.1\nConfigurar Django para usar MongoDB:\nModifica el archivo settings.py de tu proyecto Django y ajusta la configuración de la base de datos:\n\n # settings.py\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'publicaciones',\n    'djongo',\n]\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'djongo',\n        'NAME': 'nombre_de_la_base_de_datos',\n        'CLIENT': {\n            'host': 'localhost', # Cambia esta dirección si tu servidor MongoDB está en otro equipo\n            'port': 27017,       # Puerto de MongoDB (por defecto es 27017)\n        },\n    }\n}\nAsegúrate de reemplazar nombre_de_la_base_de_datos con el nombre que deseas para tu base de datos MongoDB.\n\nRealizar migraciones:\n\nUna vez configurada la base de datos en Django, es necesario aplicar las migraciones para crear las colecciones y documentos correspondientes.\nEjecuta el siguiente comando para aplicar las migraciones:\npython manage.py makemigrations\npython manage.py migrate \n\nVerificar la conexión:\n\nFinalmente, verifica que la conexión con MongoDB se haya establecido correctamente y que puedas realizar consultas y operaciones desde tu proyecto Django.\nCon estos pasos, tendrás configurada la conexión con MongoDB en tu proyecto de Django y podrás utilizarla para almacenar y recuperar datos.\nEs importante mencionar que MongoDB es una base de datos NoSQL, lo que significa que utiliza un modelo de datos basado en documentos en lugar de tablas y filas como las bases de datos relacionales. Esto permite una mayor flexibilidad y escalabilidad en el almacenamiento de datos."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#diseño-de-un-modelo-de-usuarios-y-publicaciones-en-un-blog.",
    "href": "unidades/unidad2/unidad2.html#diseño-de-un-modelo-de-usuarios-y-publicaciones-en-un-blog.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Diseño de un Modelo de Usuarios y Publicaciones en un Blog.",
    "text": "Diseño de un Modelo de Usuarios y Publicaciones en un Blog.\n\nImportación de módulos necesarios:\nPara definir los modelos en Django, primero importamos los módulos necesarios desde la biblioteca Django.\n# models.py\n\nfrom django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\n\nDefinición del modelo “Usuario”:\nEl modelo de “Usuario” se crea mediante la herencia de la clase “AbstractUser” proporcionada por Django. Esto nos permite utilizar la funcionalidad de autenticación y autorización incorporada en Django. También podemos agregar campos adicionales según sea necesario.\n# models.py\n\nclass Usuario(AbstractUser):\n    # Agrega campos adicionales si es necesario\n    pass\nEn el modelo “Usuario”, podemos agregar campos adicionales según las necesidades específicas de nuestra aplicación. Al heredar de la clase “AbstractUser” proporcionada por Django, ya contamos con campos comunes para autenticación, como “username”, “email” y “password”.\nAdemás de los campos heredados, algunos ejemplos de campos adicionales que podríamos agregar al modelo “Usuario” son:\nNombre completo: Podemos agregar un campo para almacenar el nombre completo del usuario.\nclass Usuario(AbstractUser):\n    # Campos heredados de AbstractUser\n    ...\n\n    # Campo adicional\n    nombre_completo = models.CharField(max_length=255)\nFecha de nacimiento: Podemos incluir un campo para registrar la fecha de nacimiento del usuario.\nclass Usuario(AbstractUser):\n    # Campos heredados de AbstractUser\n    ...\n\n    # Campo adicional\n    fecha_nacimiento = models.DateField()\nBiografía: Podemos permitir que los usuarios agreguen una breve biografía sobre ellos mismos.\nclass Usuario(AbstractUser):\n    # Campos heredados de AbstractUser\n    ...\n\n    # Campo adicional\n    biografia = models.TextField(blank=True, null=True)\nImagen de perfil: Podemos agregar un campo para que los usuarios carguen una imagen de perfil.\nclass Usuario(AbstractUser):\n    # Campos heredados de AbstractUser\n    ...\n\n    # Campo adicional\n    imagen_perfil = models.ImageField(upload_to='imagenes_perfil/', blank=True, null=True)\nEstos son solo algunos ejemplos de los campos adicionales que podríamos agregar al modelo “Usuario”. La elección de los campos depende de los requisitos específicos de la aplicación y qué información adicional deseamos almacenar para nuestros usuarios.\nDjango proporciona una amplia variedad de tipos de campos para adaptarse a diferentes tipos de datos y necesidades.\n\n\nDefinición del modelo “Publicacion”:\nEl modelo “Publicacion” se crea como una subclase de “models.Model”.\nAquí definimos los campos que representarán los atributos de una publicación en el blog, como “titulo”, “contenido” y “fecha_publicacion”. Cada campo es una instancia de una clase de campo de Django que define el tipo y las propiedades del campo.\n# models.py\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=200)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField()\nMétodo “str”:\nEn el modelo “Publicacion”, hemos definido el método “str” que devuelve el título de la publicación cuando se imprime una instancia de la clase.\nEsto hace que sea más fácil identificar las publicaciones en el administrador de Django y en cualquier otra parte donde se muestren objetos de la clase “Publicacion”.\n# models.py\n\nclass Publicacion(models.Model):\n    # Campos de la publicación...\n\n    def __str__(self):\n        return self.titulo\nCon estos pasos, hemos definido los modelos “Usuario” y “Publicacion” en Django. Estos modelos representarán las tablas “Usuario” y “Publicacion” en la base de datos y nos permitirán interactuar con ellos mediante el ORM de Django."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#agrega-un-campo-adicional-al-modelo-de-publicaciones",
    "href": "unidades/unidad2/unidad2.html#agrega-un-campo-adicional-al-modelo-de-publicaciones",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Agrega un Campo Adicional al Modelo de Publicaciones",
    "text": "Agrega un Campo Adicional al Modelo de Publicaciones\n[ ] Agrega un Campo Adicional al Modelo de Publicaciones y Realiza la Migración Correspondiente\n[ ] En el modelo de Publicaciones, agrega un nuevo campo “imagen” de tipo “ImageField”.\n[ ] Crea una migración para aplicar los cambios al modelo usando el comando\n[ ] Aplica la migración a la base de datos."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#resolución-de-la-actividad-práctica.",
    "href": "unidades/unidad2/unidad2.html#resolución-de-la-actividad-práctica.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Resolución de la Actividad Práctica.",
    "text": "Resolución de la Actividad Práctica.\nPaso 1: Agregar un Campo Adicional al Modelo de Publicaciones\nEn el archivo “models.py” de la aplicación “blog”, agregamos un nuevo campo llamado “imagen” de tipo “ImageField” al modelo “Publicacion”. Esto nos permitirá almacenar imágenes relacionadas con cada publicación.\n# models.py\n\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=200)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField()\n    imagen = models.ImageField(upload_to='publicaciones/', blank=True, null=True)\n\n    def __str__(self):\n        return self.titulo\nPaso 2: Crear una Migración para Aplicar los Cambios\nDespués de agregar el nuevo campo “imagen” al modelo, necesitamos crear una migración para aplicar los cambios a la base de datos. Django nos proporciona un comando para generar automáticamente la migración.\n# Ejecutar en la terminal o consola\npython manage.py makemigrations\nPaso 3: Aplicar la Migración a la Base de Datos\nUna vez que se ha creado la migración, la aplicamos a la base de datos con el siguiente comando:\n# Ejecutar en la terminal o consola\npython manage.py migrate\nCon estos pasos, hemos agregado con éxito un campo adicional “imagen” al modelo de Publicaciones y hemos aplicado la migración a la base de datos para reflejar el cambio. Ahora, cada publicación en el blog tendrá un campo para asociar una imagen, lo que mejorará la experiencia visual para los usuarios."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#extra.",
    "href": "unidades/unidad2/unidad2.html#extra.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Extra.",
    "text": "Extra.\nPara poder manejar el modelo de Publicaciones desde la administración de Django, es necesario registrar el modelo en el archivo “admin.py” de la aplicación “blog”. De esta manera, podremos acceder a las publicaciones y administrarlas desde la interfaz de administración de Django.\nPaso 4: Registro del Modelo en el Administrador de Django\nEn el archivo “admin.py” de la aplicación “blog”, registramos el modelo “Publicacion” para que sea accesible desde la interfaz de administración.\n# admin.py\n\nfrom django.contrib import admin\nfrom .models import Publicacion\n\nadmin.site.register(Publicacion)\nCon este registro, el modelo “Publicacion” estará disponible en la interfaz de administración de Django.\nAhora, cuando ingreses a la URL “/admin/” en tu aplicación, podrás iniciar sesión como superusuario y ver la sección de “Publicacions”, donde podrás agregar, editar y eliminar publicaciones desde la interfaz de administración.\nEsto facilitará el manejo de las publicaciones sin tener que acceder directamente a la base de datos."
  },
  {
    "objectID": "unidades/unidad2/unidad2.html#conclusión.",
    "href": "unidades/unidad2/unidad2.html#conclusión.",
    "title": "Módulo 2: Modelos y Bases de Datos.",
    "section": "Conclusión.",
    "text": "Conclusión.\nCon esto, hemos completado el Módulo 2 de Modelos y Bases de Datos en Django.\nHas aprendido a diseñar modelos en Django, realizar migraciones de la base de datos, hacer consultas utilizando el ORM de Django, establecer relaciones entre modelos y usar formularios en Django.\nEn el próximo módulo, continuaremos explorando más características de Django, como vistas y plantillas."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html",
    "href": "unidades/unidad3/unidad3.html",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "",
    "text": "CRUD de Publicaciones"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#creación-de-vistas-en-django",
    "href": "unidades/unidad3/unidad3.html#creación-de-vistas-en-django",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Creación de Vistas en Django",
    "text": "Creación de Vistas en Django\nLas vistas en Django son funciones que procesan las solicitudes del usuario y devuelven una respuesta HTTP. Cada vista debe recibir una solicitud como argumento y devolver una respuesta.\nEjemplo de una vista que muestra un mensaje de bienvenida:\nPaso 1: En el archivo “views.py” de la aplicación “publicaciones”, agrega el código de la vista de bienvenida:\n# publicaciones/views.py\n\nfrom django.http import HttpResponse\n\ndef vista_bienvenida(request):\n    return HttpResponse(\"¡Bienvenido al blog!\")\nPaso 3: Configura la URL para la vista en el archivo “urls.py” de la aplicación “publicaciones”:\n# publicaciones/urls.py\n\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('bienvenida/', views.vista_bienvenida, name='vista_bienvenida'),\n]\nPaso 4: Configura la URL de la aplicación publicaciones en el archivo urls.py del proyecto:\n# blog/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('publicaciones/', include('publicaciones.urls')), # Agrega esta línea para incluir las URLs de la aplicación \"publicaciones\"\n]\nPaso 5: Ahora, ejecuta el servidor de desarrollo con el siguiente comando:\npython manage.py runserver\nPaso 6: Abre tu navegador web e ingresa a la siguiente dirección:\nhttp://127.0.0.1:8000/publicaciones/bienvenida/\nDeberías ver el mensaje “¡Bienvenido al blog!” en el navegador."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#otra-forma-de-generar-un-hola-mundo-en-django.",
    "href": "unidades/unidad3/unidad3.html#otra-forma-de-generar-un-hola-mundo-en-django.",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Otra forma de generar un Hola Mundo en Django.",
    "text": "Otra forma de generar un Hola Mundo en Django.\nPaso 1: Creación de la vista en views.py:\nEn esta etapa, se crea una vista llamada “HolaMundoView” utilizando la clase TemplateView. Esta vista simplemente renderiza la plantilla “hola_mundo.html” que muestra un mensaje “Hola Mundo!”.\n# views.py  \n\nfrom django.shortcuts import render \nfrom django.views.generic import TemplateView  \n\nclass HolaMundoView(TemplateView):     \n    template_name = 'hola_mundo.html' \nPaso 2: Configuración de las URLs en urls.py:\nEn el archivo urls.py de la aplicación “publicaciones”, se define la URL para la vista “HolaMundoView”. También se incluyen las URLs de la aplicación en las URLs globales del proyecto.\n# urls.py de publicaciones  \n\nfrom django.urls import path \nfrom .views import HolaMundoView  \n\nurlpatterns = [     \n    path('hola_mundo/', HolaMundoView.as_view(), name='hola_mundo'), ] \nPaso 3 Creación de la plantilla hola_mundo.html:\nLa plantilla “hola_mundo.html” es un archivo HTML simple que muestra el mensaje “Hola Mundo!” en un encabezado h1.\n      \n&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;head&gt;     \n&lt;title&gt;Hola Mundo&lt;/title&gt; \n&lt;/head&gt; \n&lt;body&gt;     \n&lt;h1&gt;Hola Mundo!&lt;/h1&gt; \n&lt;/body&gt; \n&lt;/html&gt; \nPaso 4: Configuración de las URLs globales del proyecto en urls.py:\nEn el archivo urls.py del proyecto principal, se incluye la URL de la aplicación “publicaciones” utilizando la función “include”. Esto permitirá acceder a las URLs de la aplicación a través de la URL base “publicaciones/”.\n\n# urls.py del proyecto  \nfrom django.contrib import admin \nfrom django.urls import path, include  \n\nurlpatterns = [     \n    path('admin/', admin.site.urls),     \n    path('publicaciones/', include('publicaciones.urls')), \n    ] \nCon estos pasos, hemos creado una aplicación simple que muestra el mensaje “Hola Mundo!” en la página cuando accedemos a la URL “publicaciones/hola_mundo/”. Además, hemos configurado la conexión entre las URLs de la aplicación y las URLs globales del proyecto. A partir de aquí, podemos agregar más funcionalidades y vistas a nuestra aplicación utilizando los modelos “Publicacion” y “Comentario”."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#mostrar-publicaciones-y-comentarios",
    "href": "unidades/unidad3/unidad3.html#mostrar-publicaciones-y-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Mostrar Publicaciones y Comentarios",
    "text": "Mostrar Publicaciones y Comentarios\nPara mostrar las publicaciones y comentarios agregados en los modelos, primero, asegúrate de que hayas definido correctamente los modelos “Publicacion” y “Comentario” en el archivo models.py de la aplicación “publicaciones” como se mostró en ejemplos anteriores."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#crea-una-vista-para-mostrar-las-publicaciones",
    "href": "unidades/unidad3/unidad3.html#crea-una-vista-para-mostrar-las-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Crea una vista para mostrar las publicaciones:",
    "text": "Crea una vista para mostrar las publicaciones:\nEn el archivo views.py de la aplicación “publicaciones”, crea una vista llamada “ListaPublicacionesView” para mostrar todas las publicaciones:\n# publicaciones/views.py\n\nfrom django.views.generic import ListView\nfrom .models import Publicacion\n\nclass ListaPublicacionesView(ListView):\n    model = Publicacion\n    template_name = 'lista_publicaciones.html'\n    context_object_name = 'publicaciones'\nCrea una plantilla para mostrar la lista de publicaciones:\nCrea un archivo llamado “lista_publicaciones.html” dentro de la carpeta “templates” de la aplicación “publicaciones”:\n&lt;!-- publicaciones/templates/lista_publicaciones.html --&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Publicaciones&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for publicacion in publicaciones %}\n            &lt;li&gt;{{ publicacion.titulo }}&lt;/li&gt;\n            &lt;ul&gt;\n                {% for comentario in publicacion.comentarios.all %}\n                    &lt;li&gt;{{ comentario.texto }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nEn este ejemplo, estamos utilizando una estructura de bucles for en la plantilla para mostrar las publicaciones y sus comentarios asociados.\nConfigura las URLs para mostrar la lista de publicaciones:\nEn el archivo urls.py de la aplicación “publicaciones”, agrega la configuración para mostrar la lista de publicaciones:\n# publicaciones/urls.py\n\nfrom django.urls import path\nfrom .views import ListaPublicacionesView\n\nurlpatterns = [\n    path('publicaciones/', ListaPublicacionesView.as_view(), name='lista_publicaciones'),\n]\nActualiza las URLs del proyecto:\nEn el archivo urls.py del proyecto “blog”, actualiza las URLs de la aplicación “publicaciones” para que se muestren en la ruta principal:\n# blog/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('publicaciones.urls')),\n]\nEjecuta el servidor de desarrollo:\nAhora, ejecuta el servidor de desarrollo nuevamente con el siguiente comando:\npython manage.py runserver\nAccede a la URL http://localhost:8000/publicaciones/ en tu navegador y deberías ver la lista de publicaciones y sus comentarios asociados.\nSi no has agregado publicaciones o comentarios en la base de datos, es posible que no veas datos en la lista.\n¡Listo! Ahora has configurado el proyecto “blog” para mostrar las publicaciones y comentarios agregados en los modelos “Publicacion” y “Comentario” utilizando el modelo Template View de Django."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#sistema-de-plantillas-de-django-jinja2",
    "href": "unidades/unidad3/unidad3.html#sistema-de-plantillas-de-django-jinja2",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Sistema de Plantillas de Django (Jinja2)",
    "text": "Sistema de Plantillas de Django (Jinja2)\n\nDjango utiliza el motor de plantillas Jinja2 para gestionar la presentación de los datos en las vistas.\nJinja2 es un poderoso motor de plantillas que permite incrustar código Python y generar HTML de forma dinámica.\nEn el contexto del proyecto “blog” que hemos estado desarrollando, el sistema de plantillas de Django se encargará de renderizar las vistas y mostrar las publicaciones con sus comentarios en la plantilla “lista_publicaciones.html”."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#conceptos-principales-del-sistema-de-plantillas-de-django",
    "href": "unidades/unidad3/unidad3.html#conceptos-principales-del-sistema-de-plantillas-de-django",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Conceptos Principales del Sistema de Plantillas de Django:",
    "text": "Conceptos Principales del Sistema de Plantillas de Django:\nTemplates: Los templates son archivos HTML que contienen código Python que define cómo se mostrarán los datos en la interfaz de usuario.\nEn nuestro caso, el archivo “lista_publicaciones.html” será un template donde mostraremos la lista de publicaciones y sus comentarios.\nContexto: El contexto es un diccionario de Python que contiene los datos que se van a renderizar en el template.\nEn este contexto, proporcionaremos la lista de publicaciones y sus comentarios para que sean mostrados en la plantilla.\nVariables de Plantilla: En los templates de Django, podemos utilizar variables de plantilla para acceder a los datos proporcionados en el contexto.\nPor ejemplo, podemos utilizar la variable publicaciones para acceder a la lista de publicaciones y sus comentarios.\nDirectivas de Control: Jinja2 permite utilizar directivas de control, como bucles y condicionales, en los templates para generar contenido de forma dinámica.\nEsto nos permite iterar sobre la lista de publicaciones y mostrar cada una de ellas con sus comentarios."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#pasos-para-utilizar-el-sistema-de-plantillas-de-django-en-el-proyecto-blog",
    "href": "unidades/unidad3/unidad3.html#pasos-para-utilizar-el-sistema-de-plantillas-de-django-en-el-proyecto-blog",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Pasos para Utilizar el Sistema de Plantillas de Django en el Proyecto “blog”:",
    "text": "Pasos para Utilizar el Sistema de Plantillas de Django en el Proyecto “blog”:\nPasos para Utilizar el Sistema de Plantillas de Django en el Proyecto “blog”:\nPaso 1: Crear el archivo “lista_publicaciones.html”\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “lista_publicaciones.html” donde definiremos la estructura HTML y utilizaremos las variables de plantilla para mostrar los datos.\n&lt;!-- lista_publicaciones.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Publicaciones&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for publicacion in publicaciones %}\n        &lt;li&gt;\n            &lt;h2&gt;{{ publicacion.titulo }}&lt;/h2&gt;\n            &lt;p&gt;{{ publicacion.contenido }}&lt;/p&gt;\n            &lt;h3&gt;Comentarios:&lt;/h3&gt;\n            &lt;ul&gt;\n                {% for comentario in publicacion.comentarios.all %}\n                &lt;li&gt;{{ comentario.texto }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 2: Definir las Vistas\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos las vistas que serán responsables de obtener los datos de la base de datos (en este caso, las publicaciones y sus comentarios) y pasarlos al template.\n# views.py\nfrom django.shortcuts import render\nfrom .models import Publicacion\n\ndef lista_publicaciones(request):\n    publicaciones = Publicacion.objects.all()\n    context = {'publicaciones': publicaciones}\n    return render(request, 'lista_publicaciones.html', context)\nPaso 3: Utilizar el Contexto\nEn las vistas, creamos un contexto que contiene los datos que queremos mostrar en el template. En nuestro caso, el contexto contendrá la lista de publicaciones y sus comentarios.\nPaso 4: Renderizar el Template\nFinalmente, en las vistas, utilizamos el método render() para renderizar el template “lista_publicaciones.html” con el contexto que creamos. Esto generará el contenido HTML dinámico que mostrará las publicaciones y sus comentarios.\nPaso 5: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, definimos la URL que se utilizará para acceder a la vista que renderiza el template “lista_publicaciones.html”.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n]\nCon estos pasos, habremos integrado el sistema de plantillas de Django (Jinja2) en nuestro proyecto “blog” y podremos mostrar de forma dinámica las publicaciones y sus comentarios en la plantilla “lista_publicaciones.html”. Al acceder a la URL “/lista/”, se mostrará la lista de publicaciones con sus comentarios."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#crear-publicaciones",
    "href": "unidades/unidad3/unidad3.html#crear-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Crear Publicaciones",
    "text": "Crear Publicaciones\nPaso 1: Crear el formulario de Publicación\nEn el archivo “forms.py” de la aplicación “publicaciones”, creamos un formulario para la creación de publicaciones.\n# forms.py\nfrom django import forms\nfrom .models import Publicacion\n\nclass PublicacionForm(forms.ModelForm):\n    class Meta:\n        model = Publicacion\n        fields = ['titulo', 'contenido', 'autor']\nPaso 2: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para crear una nueva publicación y renderizar el formulario.\n# views.py\nfrom django.shortcuts import render, redirect\nfrom .forms import PublicacionForm\n\ndef crear_publicacion(request):\n    if request.method == 'POST':\n        form = PublicacionForm(request.POST)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = PublicacionForm()\n    return render(request, 'crear_publicacion.html', {'form': form})\nPaso 3: Crear la plantilla para el formulario de creación\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “crear_publicacion.html” que contendrá el formulario de creación de publicaciones.\n&lt;!-- crear_publicacion.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Crear Publicación&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Crear Nueva Publicación&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Crear&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 4: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de creación de publicaciones.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#leer-publicaciones",
    "href": "unidades/unidad3/unidad3.html#leer-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Leer Publicaciones",
    "text": "Leer Publicaciones\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para mostrar la lista de publicaciones.\n# views.py\nfrom django.shortcuts import render\nfrom .models import Publicacion\n\ndef lista_publicaciones(request):\n    publicaciones = Publicacion.objects.all()\n    return render(request, 'lista_publicaciones.html', {'publicaciones': publicaciones})\nPaso 2: Actualizar el archivo “lista_publicaciones.html”\nEn la plantilla “lista_publicaciones.html”, podemos acceder a las publicaciones y mostrarlas en una lista.\n&lt;!-- lista_publicaciones.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Publicaciones&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for publicacion in publicaciones %}\n        &lt;li&gt;\n            &lt;h2&gt;{{ publicacion.titulo }}&lt;/h2&gt;\n            &lt;p&gt;{{ publicacion.contenido }}&lt;/p&gt;\n            &lt;h3&gt;Comentarios:&lt;/h3&gt;\n            &lt;ul&gt;\n                {% for comentario in publicacion.comentarios.all %}\n                &lt;li&gt;{{ comentario.texto }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#actualizar-publicaciones",
    "href": "unidades/unidad3/unidad3.html#actualizar-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Actualizar Publicaciones",
    "text": "Actualizar Publicaciones\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para actualizar una publicación existente.\n# views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .forms import PublicacionForm\nfrom .models import Publicacion\n\ndef actualizar_publicacion(request, pk):\n    publicacion = get_object_or_404(Publicacion, pk=pk)\n    if request.method == 'POST':\n        form = PublicacionForm(request.POST, instance=publicacion)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = PublicacionForm(instance=publicacion)\n    return render(request, 'actualizar_publicacion.html', {'form': form})\nPaso 2: Crear la plantilla para el formulario de actualización\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “actualizar_publicacion.html” que contendrá el formulario de actualización de publicaciones.\n&lt;!-- actualizar_publicacion.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Actualizar Publicación&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Actualizar Publicación&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Guardar Cambios&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 3: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de actualización de publicaciones.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#eliminar-publicaciones",
    "href": "unidades/unidad3/unidad3.html#eliminar-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Eliminar Publicaciones",
    "text": "Eliminar Publicaciones\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para eliminar una publicación existente.\n# views.py\nfrom django.shortcuts import get_object_or_404, redirect\nfrom .models import Publicacion\n\ndef eliminar_publicacion(request, pk):\n    publicacion = get_object_or_404(Publicacion, pk=pk)\n    if request.method == 'POST':\n        publicacion.delete()\n        return redirect('lista_publicaciones')\n    return render(request, 'eliminar_publicacion.html', {'publicacion': publicacion})\nPaso 2: Crear la plantilla para confirmar la eliminación\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “eliminar_publicacion.html” que contendrá la confirmación para eliminar la publicación.\n&lt;!-- eliminar_publicacion.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Eliminar Publicación&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Eliminar Publicación&lt;/h1&gt;\n    &lt;p&gt;¿Estás seguro de que deseas eliminar la publicación \"{{ publicacion.titulo }}\"?&lt;/p&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        &lt;button type=\"submit\"&gt;Eliminar&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 3: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de eliminación de publicaciones.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#crud-de-comentarios",
    "href": "unidades/unidad3/unidad3.html#crud-de-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "CRUD de Comentarios",
    "text": "CRUD de Comentarios\nEl CRUD de comentarios sigue un proceso similar al CRUD de publicaciones. A continuación, se describen los pasos para cada operación: Crear Comentarios\nPaso 1: Crear el formulario de Comentario\nEn el archivo “forms.py” de la aplicación “publicaciones”, creamos un formulario para la creación de comentarios.\n# forms.py\nfrom django import forms\nfrom .models import Comentario\n\nclass ComentarioForm(forms.ModelForm):\n    class Meta:\n        model = Comentario\n        fields = ['publicacion', 'autor', 'contenido']\nPaso 2: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para crear un nuevo comentario y renderizar el formulario.\n# views.py\nfrom django.shortcuts import render, redirect\nfrom .forms import ComentarioForm\n\ndef crear_comentario(request):\n    if request.method == 'POST':\n        form = ComentarioForm(request.POST)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = ComentarioForm()\n    return render(request, 'crear_comentario.html', {'form': form})\nPaso 3: Crear la plantilla para el formulario de creación\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “crear_comentario.html” que contendrá el formulario de creación de comentarios.\n&lt;!-- crear_comentario.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Crear Comentario&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Crear Nuevo Comentario&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Crear&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 4: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de creación de comentarios.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n    path('crear_comentario/', views.crear_comentario, name='crear_comentario'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#leer-comentarios",
    "href": "unidades/unidad3/unidad3.html#leer-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Leer Comentarios",
    "text": "Leer Comentarios\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para mostrar la lista de comentarios.\n# views.py\nfrom django.shortcuts import render\nfrom .models import Comentario\n\ndef lista_comentarios(request):\n    comentarios = Comentario.objects.all()\n    return render(request, 'lista_comentarios.html', {'comentarios': comentarios})\nPaso 2: Actualizar el archivo “lista_comentarios.html”\nEn la plantilla “lista_comentarios.html”, podemos acceder a los comentarios y mostrarlos en una lista.\n&lt;!-- lista_comentarios.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Comentarios&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Comentarios&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for comentario in comentarios %}\n        &lt;li&gt;\n            &lt;p&gt;Comentario de {{ comentario.autor }} en {{ comentario.publicacion.titulo }}&lt;/p&gt;\n            &lt;p&gt;{{ comentario.contenido }}&lt;/p&gt;\n        &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 3: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de lista de comentarios.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n    path('crear_comentario/', views.crear_comentario, name='crear_comentario'),\n    path('lista_comentarios/', views.lista_comentarios, name='lista_comentarios'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#actualizar-comentarios",
    "href": "unidades/unidad3/unidad3.html#actualizar-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Actualizar Comentarios",
    "text": "Actualizar Comentarios\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para actualizar un comentario existente.\n# views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .forms import ComentarioForm\nfrom .models import Comentario\n\ndef actualizar_comentario(request, pk):\n    comentario = get_object_or_404(Comentario, pk=pk)\n    if request.method == 'POST':\n        form = ComentarioForm(request.POST, instance=comentario)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_comentarios')\n    else:\n        form = ComentarioForm(instance=comentario)\n    return render(request, 'actualizar_comentario.html', {'form': form})\nPaso 2: Crear la plantilla para el formulario de actualización\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “actualizar_comentario.html” que contendrá el formulario de actualización de comentarios.\n&lt;!-- actualizar_comentario.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Actualizar Comentario&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Actualizar Comentario&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Guardar Cambios&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 3: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de actualización de comentarios.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n    path('crear_comentario/', views.crear_comentario, name='crear_comentario'),\n    path('lista_comentarios/', views.lista_comentarios, name='lista_comentarios'),\n    path('actualizar_comentario/&lt;int:pk&gt;/', views.actualizar_comentario, name='actualizar_comentario'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#eliminar-comentarios",
    "href": "unidades/unidad3/unidad3.html#eliminar-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Eliminar Comentarios",
    "text": "Eliminar Comentarios\nPaso 1: Actualizar el archivo “views.py”\nEn el archivo “views.py” de la aplicación “publicaciones”, definimos una vista para eliminar un comentario existente.\n# views.py\nfrom django.shortcuts import get_object_or_404, redirect\nfrom .models import Comentario\n\ndef eliminar_comentario(request, pk):\n    comentario = get_object_or_404(Comentario, pk=pk)\n    if request.method == 'POST':\n        comentario.delete()\n        return redirect('lista_comentarios')\n    return render(request, 'eliminar_comentario.html', {'comentario': comentario})\nPaso 2: Crear la plantilla para confirmar la eliminación\nEn el directorio “templates” de la aplicación “publicaciones”, creamos el archivo “eliminar_comentario.html” que contendrá la confirmación para eliminar el comentario.\n&lt;!-- eliminar_comentario.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Eliminar Comentario&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Eliminar Comentario&lt;/h1&gt;\n    &lt;p&gt;¿Estás seguro de que deseas eliminar el comentario de \"{{ comentario.autor }}\" en \"{{ comentario.publicacion.titulo }}\"?&lt;/p&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        &lt;button type=\"submit\"&gt;Eliminar&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 3: Configurar las URLs\nEn el archivo “urls.py” de la aplicación “publicaciones”, agregamos una URL para la vista de eliminación de comentarios.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n    path('crear_comentario/', views.crear_comentario, name='crear_comentario'),\n    path('lista_comentarios/', views.lista_comentarios, name='lista_comentarios'),\n    path('actualizar_comentario/&lt;int:pk&gt;/', views.actualizar_comentario, name='actualizar_comentario'),\n    path('eliminar_comentario/&lt;int:pk&gt;/', views.eliminar_comentario, name='eliminar_comentario'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#migrar-y-ejecutar-el-servidor",
    "href": "unidades/unidad3/unidad3.html#migrar-y-ejecutar-el-servidor",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Migrar y Ejecutar el Servidor",
    "text": "Migrar y Ejecutar el Servidor\nPaso 1: Aplicar las migraciones\nDespués de agregar los modelos y las vistas, es necesario aplicar las migraciones para crear las tablas correspondientes en la base de datos.\nEjecutamos el siguiente comando:\npython manage.py makemigrations\npython manage.py migrate\nPaso 2: Ejecutar el servidor\nFinalmente, para ver nuestro proyecto en funcionamiento, ejecutamos el servidor de desarrollo de Django.\nEjecutamos el siguiente comando:\npython manage.py runserver\nCon esto, podemos acceder a nuestro sistema CRUD de publicaciones y comentarios en el navegador, utilizando las URLs configuradas en las vistas y templates.\nPor ejemplo,\n\nPara ver la lista de publicaciones, accedemos a “/lista/”\nPara crear una nueva publicación, accedemos a “/crear/”.\nPara ver la lista de comentarios, accedemos a “/lista_comentarios/”\nPara crear un nuevo comentario, accedemos a “/crear_comentario/”."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#integración-de-botones.",
    "href": "unidades/unidad3/unidad3.html#integración-de-botones.",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Integración de Botones.",
    "text": "Integración de Botones.\nPara integrar los botones de actualizar y eliminar en la lista de publicaciones y comentarios, necesitamos realizar algunos cambios en las plantillas y en las vistas.\nA continuación, describo los pasos necesarios para cada uno:"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#para-las-publicaciones",
    "href": "unidades/unidad3/unidad3.html#para-las-publicaciones",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Para las Publicaciones:",
    "text": "Para las Publicaciones:\nPaso 1: Actualizar “lista_publicaciones.html” en el directorio “templates” de la aplicación “publicaciones”. Agregar los enlaces para actualizar y eliminar cada publicación.\n&lt;!-- lista_publicaciones.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Publicaciones&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for publicacion in publicaciones %}\n        &lt;li&gt;\n            &lt;h2&gt;{{ publicacion.titulo }}&lt;/h2&gt;\n            &lt;p&gt;{{ publicacion.contenido }}&lt;/p&gt;\n            &lt;a href=\"{% url 'detalle_publicacion' pk=publicacion.pk %}\"&gt;Ver detalles&lt;/a&gt;\n            &lt;a href=\"{% url 'actualizar_publicacion' pk=publicacion.pk %}\"&gt;Actualizar&lt;/a&gt;\n            &lt;a href=\"{% url 'eliminar_publicacion' pk=publicacion.pk %}\"&gt;Eliminar&lt;/a&gt;\n            &lt;ul&gt;\n                {% for comentario in publicacion.comentarios %}\n                &lt;li&gt;{{ comentario.texto }}&lt;/li&gt;\n                &lt;a href=\"{% url 'actualizar_comentario' pk=comentario.pk %}\"&gt;Actualizar&lt;/a&gt;\n                &lt;a href=\"{% url 'eliminar_comentario' pk=comentario.pk %}\"&gt;Eliminar&lt;/a&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 2: Actualizar “views.py” en la aplicación “publicaciones”. Agregar las vistas para actualizar y eliminar las publicaciones.\n# views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .forms import PublicacionForm, ComentarioForm\nfrom .models import Publicacion\n\nfrom django.shortcuts import render, redirect, get_object_or_404\nfrom .forms import PublicacionForm, ComentarioForm\nfrom .models import Publicacion, Comentario\n\ndef lista_publicaciones(request):\n    publicaciones = Publicacion.objects.all()\n    return render(request, 'lista_publicaciones.html', {'publicaciones': publicaciones})\n\ndef crear_publicacion(request):\n    if request.method == 'POST':\n        form = PublicacionForm(request.POST)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = PublicacionForm()\n    return render(request, 'crear_publicacion.html', {'form': form})\n\ndef detalle_publicacion(request, pk):\n    publicacion = get_object_or_404(Publicacion, pk=pk)\n    comentarios = Comentario.objects.filter(publicacion=publicacion)\n\n    if request.method == 'POST':\n        comentario_form = ComentarioForm(request.POST)\n        if comentario_form.is_valid():\n            comentario = comentario_form.save(commit=False)\n            comentario.publicacion = publicacion\n            comentario.save()\n            return redirect('detalle_publicacion', pk=pk)\n    else:\n        comentario_form = ComentarioForm()\n\n    context = {\n        'publicacion': publicacion,\n        'comentarios': comentarios,\n        'comentario_form': comentario_form,\n    }\n    return render(request, 'detalle_publicacion.html', context)\n\ndef actualizar_publicacion(request, pk):\n    publicacion = get_object_or_404(Publicacion, pk=pk)\n    if request.method == 'POST':\n        form = PublicacionForm(request.POST, instance=publicacion)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = PublicacionForm(instance=publicacion)\n    return render(request, 'crear_publicacion.html', {'form': form})\n\ndef eliminar_publicacion(request, pk):\n    publicacion = get_object_or_404(Publicacion, pk=pk)\n    if request.method == 'POST':\n        publicacion.delete()\n        return redirect('lista_publicaciones')\n    return render(request, 'eliminar_publicacion.html', {'publicacion': publicacion})\nPaso 3: Actualizar “urls.py” en la aplicación “publicaciones”. Agregar las URLs correspondientes para las vistas de actualizar y eliminar publicaciones.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    # Rutas de Publicaciones\n    path('lista/', views.lista_publicaciones, name='lista_publicaciones'),\n    path('crear/', views.crear_publicacion, name='crear_publicacion'),\n    path('detalle/&lt;int:pk&gt;/', views.detalle_publicacion, name='detalle_publicacion'),\n    path('actualizar/&lt;int:pk&gt;/', views.actualizar_publicacion, name='actualizar_publicacion'),\n    path('eliminar/&lt;int:pk&gt;/', views.eliminar_publicacion, name='eliminar_publicacion'),\n\n    # Rutas de Comentarios\n    path('&lt;int:pk&gt;/actualizar_comentario/', views.actualizar_comentario, name='actualizar_comentario'),\n    path('&lt;int:pk&gt;/eliminar_comentario/', views.eliminar_comentario, name='eliminar_comentario'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#para-los-comentarios",
    "href": "unidades/unidad3/unidad3.html#para-los-comentarios",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Para los Comentarios:",
    "text": "Para los Comentarios:\nEl proceso es similar al de las publicaciones, solo que debemos aplicarlo para los comentarios.\nPaso 1: Actualizar “lista_publicaciones.html” en el directorio “templates” de la aplicación “publicaciones”. Agregar los enlaces para actualizar y eliminar cada comentario.\n&lt;!-- lista_publicaciones.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Lista de Publicaciones&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for publicacion in publicaciones %}\n        &lt;li&gt;\n            &lt;h2&gt;{{ publicacion.titulo }}&lt;/h2&gt;\n            &lt;p&gt;{{ publicacion.contenido }}&lt;/p&gt;\n            &lt;a href=\"{% url 'detalle_publicacion' pk=publicacion.pk %}\"&gt;Ver detalles&lt;/a&gt;\n            &lt;a href=\"{% url 'actualizar_publicacion' pk=publicacion.pk %}\"&gt;Actualizar&lt;/a&gt;\n            &lt;a href=\"{% url 'eliminar_publicacion' pk=publicacion.pk %}\"&gt;Eliminar&lt;/a&gt;\n            &lt;ul&gt;\n                {% for comentario in publicacion.comentarios %}\n                &lt;li&gt;{{ comentario.texto }}&lt;/li&gt;\n                &lt;a href=\"{% url 'actualizar_comentario' pk=comentario.pk %}\"&gt;Actualizar&lt;/a&gt;\n                &lt;a href=\"{% url 'eliminar_comentario' pk=comentario.pk %}\"&gt;Eliminar&lt;/a&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nTambien es necesario la creación de un nuevo template llamado detalle_publicacion.html en el directorio “templates” de la aplicación “publicaciones”. Agregar los enlaces para actualizar y eliminar cada comentario.\n&lt;!-- detalle_publicacion.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Detalle de Publicación&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{{ publicacion.titulo }}&lt;/h1&gt;\n    &lt;p&gt;{{ publicacion.contenido }}&lt;/p&gt;\n    &lt;h3&gt;Comentarios:&lt;/h3&gt;\n    &lt;ul&gt;\n        {% for comentario in comentarios %}\n        &lt;li&gt;{{ comentario.contenido }}&lt;/li&gt;\n        &lt;a href=\"{% url 'actualizar_comentario' comentario.pk %}\"&gt;Actualizar Comentario&lt;/a&gt;\n        &lt;a href=\"{% url 'eliminar_comentario' comentario.pk %}\"&gt;Eliminar Comentario&lt;/a&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n\n    &lt;a href=\"{% url 'actualizar_publicacion' publicacion.pk %}\"&gt;Actualizar Publicación&lt;/a&gt;\n    &lt;a href=\"{% url 'eliminar_publicacion' publicacion.pk %}\"&gt;Eliminar Publicación&lt;/a&gt;\n\n    &lt;!-- Agregar formulario para agregar comentario --&gt;\n    &lt;h3&gt;Agregar Comentario:&lt;/h3&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ comentario_form.as_p }}\n        &lt;button type=\"submit\"&gt;Enviar Comentario&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nY finalmente actualizar el archivo actualizar_comentario.html en el directorio “templates” de la aplicación “publicaciones”. Agregar los enlaces para actualizar y eliminar cada comentario.\n&lt;!-- actualizar_comentario.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n    &lt;title&gt;Actualizar Comentario&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Actualizar Comentario&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ comentario_form.as_p }}\n        &lt;button type=\"submit\"&gt;Guardar Cambios&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nPaso 2: Actualizar “views.py” en la aplicación “publicaciones”. Agregar las vistas para actualizar y eliminar los comentarios.\n# views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .forms import PublicacionForm, ComentarioForm\nfrom .models import Publicacion, Comentario\n\ndef lista_publicaciones(request):\n    publicaciones = Publicacion.objects.all()\n    return render(request, 'lista_publicaciones.html', {'publicaciones': publicaciones})\n\ndef crear_publicacion(request):\n    # Código existente\n\ndef detalle_publicacion(request, pk):\n    # Código existente\n\ndef actualizar_publicacion(request, pk):\n    # Código existente\n\ndef eliminar_publicacion(request, pk):\n    # Código existente\n\ndef crear_comentario(request):\n    if request.method == 'POST':\n        form = ComentarioForm(request.POST)\n        if form.is_valid():\n            form.save()\n            return redirect('lista_publicaciones')\n    else:\n        form = ComentarioForm()\n    return render(request, 'crear_comentario.html', {'form': form})\n\ndef lista_comentarios(request):\n    comentarios = Comentario.objects.all()\n    return render(request, 'lista_comentarios.html', {'comentarios': comentarios})\n\ndef actualizar_comentario(request, pk):\n    comentario = get_object_or_404(Comentario, pk=pk)\n\n    if request.method == 'POST':\n        comentario_form = ComentarioForm(request.POST, instance=comentario)\n        if comentario_form.is_valid():\n            comentario_form.save()\n            return redirect('detalle_publicacion', pk=comentario.publicacion.pk)\n    else:\n        comentario_form = ComentarioForm(instance=comentario)\n\n    context = {\n        'comentario_form': comentario_form,\n    }\n    return render(request, 'actualizar_comentario.html', context)\n\ndef eliminar_comentario(request, pk):\n    comentario = get_object_or_404(Comentario, pk=pk)\n    publicacion_pk = comentario.publicacion.pk\n    comentario.delete()\n    return redirect('detalle_publicacion', pk=publicacion_pk)\nPaso 3: Actualizar “urls.py” en la aplicación “publicaciones”. Agregar las URLs correspondientes para las vistas de actualizar y eliminar comentarios.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    # Rutas de Comentarios\n    path('&lt;int:pk&gt;/actualizar_comentario/', views.actualizar_comentario, name='actualizar_comentario'),\n    path('&lt;int:pk&gt;/eliminar_comentario/', views.eliminar_comentario, name='eliminar_comentario'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#corregir-el-modelo",
    "href": "unidades/unidad3/unidad3.html#corregir-el-modelo",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Corregir el Modelo",
    "text": "Corregir el Modelo\nFinalmente para corregir el modelo y hacer que el campo autor herede los datos de User de Django, podemos usar un campo ForeignKey que apunte al modelo User.\nEsto nos permitirá asociar cada publicación y comentario a un usuario específico. Aquí está el código corregido:\nfrom django.contrib.auth.models import User\nfrom django.db import models\n\nclass Publicacion(models.Model):\n    titulo = models.CharField(max_length=200)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField(auto_now_add=True)\n    autor = models.ForeignKey(User, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.titulo\n\nclass Comentario(models.Model):\n    publicacion = models.ForeignKey(Publicacion, on_delete=models.CASCADE)\n    autor = models.ForeignKey(User, on_delete=models.CASCADE)\n    contenido = models.TextField()\n    fecha_publicacion = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return f\"Comentario de {self.autor.username} en {self.publicacion.titulo}\"\nEn este código, hemos modificado el campo autor en ambos modelos para que sea un ForeignKey que apunta al modelo User de Django.\nCon esto, cada publicación y comentario estará asociado a un usuario registrado en el sistema.\nEl argumento on_delete=models.CASCADE en el campo autor de Comentario asegura que si un usuario es eliminado, también se eliminarán todos sus comentarios relacionados, pero ten en cuenta que esto es opcional y depende de la lógica de negocio que desees implementar."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#backend-construcción-de-una-api-con-django-rest-framework",
    "href": "unidades/unidad3/unidad3.html#backend-construcción-de-una-api-con-django-rest-framework",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Backend: Construcción de una API con Django Rest Framework",
    "text": "Backend: Construcción de una API con Django Rest Framework\nEn esta sección, dividiremos todo lo que hemos realizado hasta ahora en una API utilizando Django Rest Framework (DRF). Esto nos permitirá exponer nuestros modelos (Publicacion y Comentario) como puntos finales (endpoints) para realizar operaciones CRUD (Crear, Leer, Actualizar y Eliminar) a través de peticiones HTTP.\nPaso 1: Instalar Django Rest Framework\nPrimero, debemos instalar Django Rest Framework en nuestro entorno virtual. Ejecuta el siguiente comando:\npip install djangorestframework\nPaso 2: Configurar Django Rest Framework en el Proyecto\nEn el archivo settings.py del proyecto, agrega ‘rest_framework’ a la lista de aplicaciones instaladas:\nINSTALLED_APPS = [\n    # Otras aplicaciones...\n    'rest_framework',\n]\nPaso 3: Serializadores\nEn DRF, los serializadores se utilizan para convertir nuestros modelos de Django en formatos JSON y viceversa. Vamos a crear los serializadores para los modelos Publicacion y Comentario en un archivo serializers.py dentro de la aplicación publicaciones.\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Publicacion, Comentario\n\nclass ComentarioSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Comentario\n        fields = '__all__'\n\nclass PublicacionSerializer(serializers.ModelSerializer):\n    comentarios = ComentarioSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Publicacion\n        fields = '__all__'\nEn este código, creamos dos serializadores, ComentarioSerializer y PublicacionSerializer, que utilizan el modelo correspondiente y definen los campos que queremos exponer en nuestra API. En el caso de la publicación, utilizamos comentarios para mostrar los comentarios relacionados.\nPaso 4: Vistas\nVamos a modificar nuestras vistas para utilizar los serializadores y convertir nuestros datos en formato JSON. En el archivo views.py de la aplicación publicaciones, actualiza el contenido de las vistas de la siguiente manera:\n# views.py\nfrom rest_framework import generics\nfrom .models import Publicacion, Comentario\nfrom .serializers import PublicacionSerializer, ComentarioSerializer\n\nclass ListaPublicaciones(generics.ListCreateAPIView):\n    queryset = Publicacion.objects.all()\n    serializer_class = PublicacionSerializer\n\nclass DetallePublicacion(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Publicacion.objects.all()\n    serializer_class = PublicacionSerializer\n\nclass ListaComentarios(generics.ListCreateAPIView):\n    queryset = Comentario.objects.all()\n    serializer_class = ComentarioSerializer\n\nclass DetalleComentario(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Comentario.objects.all()\n    serializer_class = ComentarioSerializer\nPaso 5: URLs\nAhora, vamos a configurar las URLs de nuestra API en el archivo urls.py de la aplicación publicaciones.\n# urls.py\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('publicaciones/', views.ListaPublicaciones.as_view(), name='lista_publicaciones'),\n    path('publicaciones/&lt;int:pk&gt;/', views.DetallePublicacion.as_view(), name='detalle_publicacion'),\n    path('comentarios/', views.ListaComentarios.as_view(), name='lista_comentarios'),\n    path('comentarios/&lt;int:pk&gt;/', views.DetalleComentario.as_view(), name='detalle_comentario'),\n]\nEn este código, configuramos las URLs de nuestras vistas utilizando las vistas basadas en clases proporcionadas por DRF. Creamos puntos finales (endpoints) para listar, crear, ver, actualizar y eliminar publicaciones y comentarios.\n¡Hemos construido una API básica para nuestro proyecto “Blog” utilizando Django Rest Framework!\nAhora podemos realizar operaciones CRUD a través de las peticiones HTTP en nuestros modelos de Publicacion y Comentario."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#documentación-de-las-api",
    "href": "unidades/unidad3/unidad3.html#documentación-de-las-api",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Documentación de las API",
    "text": "Documentación de las API\nPara documentar las API, podemos utilizar la herramienta drf-yasg. La información la vamos a obtener de la documentación oficial en el siguiente link\nDocumentación de drf-yasg\nPaso 1: Instalar drf-yasg\nPrimero, debemos instalar drf-yasg en nuestro entorno virtual. Ejecuta el siguiente comando:\npip install -U drf-yasg\nPaso 2: Configurar drf-yasg en el Proyecto\nEn el archivo settings.py del proyecto, agrega ‘drf_yasg’ a la lista de aplicaciones instaladas:\nINSTALLED_APPS = [\n    # Otras aplicaciones...\n    'drf_yasg',\n]\nPaso 3: Configurar drf-yasg en el archivo urls.py\nEn el archivo urls.py del proyecto, agrega las siguientes líneas de código:\n# urls.py\n...\nfrom django.urls import re_path\nfrom rest_framework import permissions\nfrom drf_yasg.views import get_schema_view\nfrom drf_yasg import openapi\n\n...\n\nschema_view = get_schema_view(\n    openapi.Info(\n        title=\"Snippets API\",\n        default_version='v1',\n        description=\"Test description\",\n        terms_of_service=\"https://www.google.com/policies/terms/\",\n        contact=openapi.Contact(email=\"contact@snippets.local\"),\n        license=openapi.License(name=\"BSD License\"),\n    ),\n    public=True,\n    permission_classes=(permissions.AllowAny,),\n)\n\nurlpatterns = [\n    path('swagger&lt;format&gt;/', schema_view.without_ui(cache_timeout=0), name='schema-json'),\n    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),\n    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),\n    ...\n]\nPaso 4: Agregar la variable autenticacion_classes.\nEn el archivo url.py del proyecto agregar la variable authentication_classes para que no nos pida autenticación para poder ver la documentación de las API.\n# urls.py\n...\nauthentication_classes = []\n...\nPaso 5: Ejecutar el servidor\nEjecuta el servidor y en el navegador ingresa a http://localhost:8000/swagger o http://localhost:8000/redoc\npython manage.py runserver\nTambien puedes probar los plugins de VSCode RappidApi Client o Thunder Client para poder ver la documentación de las API desde el editor de código.\nEn la siguiente sección, construiremos el frontend para consumir esta API."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#herencia-de-plantillas",
    "href": "unidades/unidad3/unidad3.html#herencia-de-plantillas",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Herencia de Plantillas",
    "text": "Herencia de Plantillas\nPara iniciar con el tema de herencia de plantillas de django, es necesario generar un archivo base.html que será nuestra plantilla base para la generación de las demás plantillas.\nEn esta plantilla base incluiremos una barra de navegación con accesos a archivos estáticos de Home, Contacto, Quienes somos y Crear Publicación.\n\nAbre el archivo base.html en el directorio templates de tu proyecto.\nAgrega el siguiente código para definir la barra de navegación:\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{% block title %}Mi Blog{% endblock %}&lt;/title&gt;\n    &lt;!-- Agregar enlaces a Bootstrap CSS --&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;nav class=\"navbar navbar-expand navbar-dark bg-dark\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;a class=\"navbar-brand\" href=\"{% url 'home' %}\"&gt;Mi Blog&lt;/a&gt;\n            &lt;ul class=\"navbar-nav ml-auto\"&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'home' %}\"&gt;Creditos&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'contacto' %}\"&gt;Contacto&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'quienes_somos' %}\"&gt;Quienes Somos&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'crear_publicacion' %}\"&gt;Crear&lt;/a&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    &lt;/nav&gt;\n\n    &lt;div class=\"container mt-4\"&gt;\n        {% block content %}\n        {% endblock %}\n    &lt;/div&gt;\n\n    &lt;!-- Agregar enlaces a Bootstrap JS y jQuery --&gt;\n    &lt;script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.1/dist/umd/popper.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nEn este código, hemos definido una etiqueta\n\nque contiene enlaces  para “Home”, “Contacto”, “Quienes Somos” y “Crear”. Los enlaces utilizan las etiquetas {% url %} de Django para generar las URLs correspondientes a cada vista.\n\nEn cada plantilla que extienda de base.html, asegúrate de agregar bloques de contenido para el título y el contenido específico de cada página:\n\nPor ejemplo, en la plantilla lista_publicaciones.html:\n{% extends 'base.html' %}\n\n{% block title %}Lista de Publicaciones{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n&lt;!-- Contenido de la lista de publicaciones --&gt;\n{% endblock %}\nEn la plantilla detalle_publicacion.html:\n{% extends 'base.html' %}\n\n{% block title %}Detalle de Publicación{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Detalle de Publicación&lt;/h1&gt;\n&lt;!-- Contenido del detalle de la publicación --&gt;\n{% endblock %}\nY así sucesivamente para las demás plantillas que extiendan de base.html."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#modificación-de-views.",
    "href": "unidades/unidad3/unidad3.html#modificación-de-views.",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Modificación de Views.",
    "text": "Modificación de Views.\nVista y URL para la página “Home”:\n# views.py\nfrom django.shortcuts import render\n\ndef home_view(request):\n    return render(request, 'home.html')\n\n# urls.py del proyecto\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('home/', views.home_view, name='home'),\n    # otras URLs de tu proyecto\n]\n\nVista y URL para la página “Contacto”:\n\n# views.py\nfrom django.shortcuts import render\n\ndef contacto_view(request):\n    return render(request, 'contacto.html')\n\n# urls.py del proyecto\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    # otras URLs de tu proyecto\n    path('contacto/', views.contacto_view, name='contacto'),\n]\nVista y URL para la página “Quienes Somos”:\n# views.py\nfrom django.shortcuts import render\n\ndef quienes_somos_view(request):\n    return render(request, 'quienes_somos.html')\n\n# urls.py del proyecto\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    # otras URLs de tu proyecto\n    path('quienes_somos/', views.quienes_somos_view, name='quienes_somos'),\n]\n\nVista y URL para la página “Crear”:\n\n# views.py\nfrom django.shortcuts import render\n\ndef crear_view(request):\n    return render(request, 'crear.html')\n\n# urls.py del proyecto\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    # otras URLs de tu proyecto\n    path('crear/', views.crear_view, name='crear_publicacion'),\n]"
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#bootstrap-en-base.html",
    "href": "unidades/unidad3/unidad3.html#bootstrap-en-base.html",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Bootstrap en base.html",
    "text": "Bootstrap en base.html\nPara incluir Bootstrap en el archivo base.html, debes agregar las etiquetas  y\n\n&lt;script src=\"https://cdn.jsdelivr.net/npm/@popperjs/core@2.0.7/dist/umd/popper.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js\"&gt;&lt;/script&gt;\n\n\nEste código incluye las hojas de estilos y scripts de Bootstrap desde sus respectivos CDNs (Content Delivery Network). Así no será necesario descargarlos ni alojarlos en tu proyecto. \n\nSi prefieres tener los archivos locales en tu proyecto, simplemente descárgalos desde la página oficial de Bootstrap (https://getbootstrap.com/) y reemplaza las URL del código por las ubicaciones locales de los archivos.\n\nCon esta modificación, tu archivo base.html utilizará Bootstrap y tendrás una barra de navegación con el estilo proporcionado por Bootstrap. Además, cualquier contenido que agregues en los bloques {% block content %} se verá dentro de un contenedor con márgenes en la parte superior, dándole un espaciado agradable al contenido.\n\n## Inclusión de Herencia de Plantillas en las demás plantillas.\n\n1. Template de home.html.\n\n``` html\n{% extends 'base.html' %}\n\n{% block title %}Home - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Bienvenido a Mi Blog&lt;/h1&gt;\n&lt;p&gt;Este es el contenido de la página de inicio.&lt;/p&gt;\n{% endblock %}\n\nTemplate de contacto.html.\n\n{% extends 'base.html' %}\n\n{% block title %}Contacto - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Contacto&lt;/h1&gt;\n&lt;p&gt;Información de contacto y formulario de contacto.&lt;/p&gt;\n{% endblock %}\n\nTemplate de quienes_somos.html.\n\n{% extends 'base.html' %}\n\n{% block title %}Quienes Somos - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;h1&gt;Quienes Somos&lt;/h1&gt;\n&lt;p&gt;Información sobre nosotros y nuestra historia.&lt;/p&gt;\n{% endblock %}\nEn cada uno de estos templates, utilizamos la etiqueta {% extends ‘base.html’ %} para indicar que estamos heredando el contenido y la estructura del archivo base.html. Luego, en el bloque {% block content %}, agregamos el contenido específico de cada página.\nCada template tiene su título personalizado en el bloque {% block title %}.\nCuando se acceda a las URLs correspondientes a cada template, se mostrará el contenido específico de cada página dentro del contenedor proporcionado por el archivo base.html, y la barra de navegación con los enlaces a Home, Contacto, Quienes Somos y Crear se mantendrá visible en todas las páginas gracias a la herencia."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#agregando-bootstrap-a-los-templates.",
    "href": "unidades/unidad3/unidad3.html#agregando-bootstrap-a-los-templates.",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Agregando bootstrap a los templates.",
    "text": "Agregando bootstrap a los templates.\nara agregar Bootstrap a las plantillas anteriores, necesitaremos incluir los enlaces a los archivos CSS y JS de Bootstrap en el archivo base.html. Además, podemos utilizar las clases de Bootstrap para mejorar la apariencia de los elementos en cada página.\nA continuación, se muestran las plantillas actualizadas con Bootstrap:\n\nTemplate de base.html\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{% block title %}Mi Blog{% endblock %}&lt;/title&gt;\n    &lt;!-- Agregar enlaces a Bootstrap CSS --&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;nav class=\"navbar navbar-expand navbar-dark bg-dark\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;a class=\"navbar-brand\" href=\"{% url 'home' %}\"&gt;Mi Blog&lt;/a&gt;\n            &lt;ul class=\"navbar-nav ml-auto\"&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'contacto' %}\"&gt;Contacto&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'quienes_somos' %}\"&gt;Quienes Somos&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"nav-item\"&gt;\n                    &lt;a class=\"nav-link\" href=\"{% url 'crear_publicacion' %}\"&gt;Crear&lt;/a&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    &lt;/nav&gt;\n\n    &lt;div class=\"container mt-4\"&gt;\n        {% block content %}\n        {% endblock %}\n    &lt;/div&gt;\n\n    &lt;!-- Agregar enlaces a Bootstrap JS y jQuery --&gt;\n    &lt;script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.1/dist/umd/popper.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nTemplate de home.html.\n\n{% extends 'base.html' %}\n\n{% block title %}Home - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;div class=\"jumbotron\"&gt;\n    &lt;h1 class=\"display-4\"&gt;Bienvenido a Mi Blog&lt;/h1&gt;\n    &lt;p class=\"lead\"&gt;Este es el contenido de la página de inicio.&lt;/p&gt;\n&lt;/div&gt;\n{% endblock %}\n\nTemplate de contacto.html.\n\n{% extends 'base.html' %}\n\n{% block title %}Contacto - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;div class=\"row\"&gt;\n    &lt;div class=\"col-md-6 mx-auto\"&gt;\n        &lt;h1&gt;Contacto&lt;/h1&gt;\n        &lt;p&gt;Información de contacto y formulario de contacto.&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n{% endblock %}\n\nTemplate de quienes_somos.html\n\n{% extends 'base.html' %}\n\n{% block title %}Quienes Somos - Mi Blog{% endblock %}\n\n{% block content %}\n&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Quienes Somos&lt;/h1&gt;\n    &lt;p&gt;Información sobre nosotros y nuestra historia.&lt;/p&gt;\n&lt;/div&gt;\n{% endblock %}\nEn estas plantillas, hemos utilizado las clases de Bootstrap para dar estilo a los elementos. Por ejemplo, en el archivo base.html, hemos utilizado la clase “navbar” para crear la barra de navegación y la clase “jumbotron” para resaltar el contenido de la página de inicio. Además, en los templates de contacto.html y quienes_somos.html, hemos utilizado la clase “container” para centrar el contenido y la clase “row” para crear una fila que contenga el contenido."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#frontend-con-reactjs",
    "href": "unidades/unidad3/unidad3.html#frontend-con-reactjs",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Frontend con Reactjs",
    "text": "Frontend con Reactjs\nPara crear un proyecto desde cero en ReactJS que consuma los datos de la API creada con Django Rest Framework, sigue estos pasos:\nPaso 1: Verificar versiones de Node.js y npm.\nAntes de comenzar, asegúrate de tener Node.js y npm instalados en tu sistema. Abre la terminal y ejecuta los siguientes comandos para verificar las versiones:\nnode -v\nnpm -v\nPaso 2: Crear un nuevo proyecto de React\nCrea un nuevo proyecto de React utilizando create-react-app. Ejecuta el siguiente comando en la terminal:\nnpx create-react-app frontend\nEsto creará una nueva carpeta llamada “frontend” con una estructura de proyecto de React preconfigurada.\nPaso 3: Instalar axios\nEn la carpeta “frontend”, instala la librería axios para realizar peticiones HTTP a la API de Django. Ejecuta el siguiente comando en la terminal:\ncd frontend\nnpm install axios\nPaso 4: Crear el componente ListaPublicaciones.js\nCrea el componente ListaPublicaciones.js en la carpeta “src/components” con el siguiente contenido:\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst ListaPublicaciones = () =&gt; {\n  const [publicaciones, setPublicaciones] = useState([]);\n\n  useEffect(() =&gt; {\n    const fetchPublicaciones = async () =&gt; {\n      try {\n        const response = await axios.get('http://localhost:8000/publicaciones/');\n        setPublicaciones(response.data.results);\n      } catch (error) {\n        console.error('Error al obtener las publicaciones:', error);\n      }\n    };\n\n    fetchPublicaciones();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Lista de Publicaciones&lt;/h1&gt;\n      &lt;ul&gt;\n        {publicaciones.map((publicacion) =&gt; (\n          &lt;li key={publicacion.id}&gt;\n            &lt;h2&gt;{publicacion.titulo}&lt;/h2&gt;\n            &lt;p&gt;{publicacion.contenido}&lt;/p&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ListaPublicaciones;\nPaso 5: Crear el componente CrearPublicacion.js\nCrea el componente CrearPublicacion.js en la carpeta “src/components” con el siguiente contenido:\nimport React from 'react';\nimport axios from 'axios';\n\nconst CrearPublicacion = () =&gt; {\n  const [titulo, setTitulo] = React.useState('');\n  const [contenido, setContenido] = React.useState('');\n\n  // Replace \"1\" with the ID of the author you want to associate with the publicación\n  const autorId = 1;\n\n  const handleCrear = async () =&gt; {\n    try {\n      await axios.post('http://localhost:8000/publicaciones/', {\n        titulo,\n        contenido,\n        autor: autorId,\n      });\n      alert('Publicación creada correctamente.');\n      setTitulo('');\n      setContenido('');\n    } catch (error) {\n      console.error('Error al crear la publicación:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Crear Publicación&lt;/h1&gt;\n      &lt;label&gt;\n        Título:\n        &lt;input type=\"text\" value={titulo} onChange={(e) =&gt; setTitulo(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;label&gt;\n        Contenido:\n        &lt;textarea value={contenido} onChange={(e) =&gt; setContenido(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;button onClick={handleCrear}&gt;Crear&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CrearPublicacion;\nPaso 6: Crear el componente ActualizarPublicacion.js\nCrea el componente ActualizarPublicacion.js en la carpeta “src/components” con el siguiente contenido:\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst ActualizarPublicacion = () =&gt; {\n  const [titulo, setTitulo] = useState('');\n  const [contenido, setContenido] = useState('');\n  const [autor, setAutor] = useState('');\n\n  // Replace \"3\" with the ID of the publicación you want to update\n  const publicacionId = 3;\n\n  useEffect(() =&gt; {\n    const fetchPublicacion = async () =&gt; {\n      try {\n        const response = await axios.get(`http://localhost:8000/publicaciones/${publicacionId}/`);\n        const { titulo, contenido, autor } = response.data;\n        setTitulo(titulo);\n        setContenido(contenido);\n        setAutor(autor);\n      } catch (error) {\n        console.error('Error al obtener la publicación:', error);\n      }\n    };\n\n    fetchPublicacion();\n  }, [publicacionId]);\n\n  const handleActualizar = async () =&gt; {\n    try {\n      await axios.put(`http://localhost:8000/publicaciones/${publicacionId}/`, {\n        titulo,\n        contenido,\n        autor,\n      });\n      alert('Publicación actualizada correctamente.');\n    } catch (error) {\n      console.error('Error al actualizar la publicación:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Actualizar Publicación&lt;/h1&gt;\n      &lt;label&gt;\n        Título:\n        &lt;input type=\"text\" value={titulo} onChange={(e) =&gt; setTitulo(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;label&gt;\n        Contenido:\n        &lt;textarea value={contenido} onChange={(e) =&gt; setContenido(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;label&gt;\n        Autor:\n        &lt;input type=\"number\" value={autor} onChange={(e) =&gt; setAutor(Number(e.target.value))} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;button onClick={handleActualizar}&gt;Actualizar&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ActualizarPublicacion;\nPaso 7: Crear el componente EliminarPublicacion.js\nCrea el componente EliminarPublicacion.js en la carpeta “src/components” con el siguiente contenido:\nimport React, { useEffect } from 'react';\nimport axios from 'axios';\n\nconst EliminarPublicacion = () =&gt; {\n  // Replace \"2\" with the ID of the publicación you want to delete\n  const publicacionId = 2;\n\n  useEffect(() =&gt; {\n    const fetchPublicacion = async () =&gt; {\n      try {\n        const response = await axios.get(`http://localhost:8000/publicaciones/${publicacionId}/`);\n        const { titulo, contenido, autor } = response.data;\n        console.log('Publicación a eliminar:', { titulo, contenido, autor });\n      } catch (error) {\n        console.error('Error al obtener la publicación:', error);\n      }\n    };\n\n    fetchPublicacion();\n  }, [publicacionId]);\n\n  const handleEliminar = async () =&gt; {\n    try {\n      await axios.delete(`http://localhost:8000/publicaciones/${publicacionId}/`);\n      alert('Publicación eliminada correctamente.');\n    } catch (error) {\n      console.error('Error al eliminar la publicación:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Eliminar Publicación&lt;/h1&gt;\n      &lt;p&gt;¿Estás seguro de que deseas eliminar esta publicación?&lt;/p&gt;\n      &lt;button onClick={handleEliminar}&gt;Eliminar&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default EliminarPublicacion;\nPaso 8: Crear el componente Home.js\nCrea el componente Home.js en la carpeta “src/components” con el siguiente contenido:\nimport React from 'react';\n\nconst Home = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Bienvenido a la página de inicio&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\nPaso 9: Crear el componente NavBar.js\nCrea el componente NavBar.js en la carpeta “src/components” con el siguiente contenido:\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nconst NavBar = () =&gt; {\n  return (\n    &lt;nav className=\"navbar navbar-expand navbar-dark bg-dark\"&gt;\n      &lt;div className=\"container\"&gt;\n        &lt;Link className=\"navbar-brand\" to=\"/\"&gt;Mi Blog&lt;/Link&gt;\n        &lt;ul className=\"navbar-nav ml-auto\"&gt;\n          &lt;li className=\"nav-item\"&gt;\n            &lt;Link className=\"nav-link\" to=\"/\"&gt;Home&lt;/Link&gt;\n          &lt;/li&gt;\n          &lt;li className=\"nav-item\"&gt;\n            &lt;Link className=\"nav-link\" to=\"/crear\"&gt;Crear&lt;/Link&gt;\n          &lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    &lt;/nav&gt;\n  );\n};\n\nexport default NavBar;\nPaso 10: Actualizar el archivo App.js\nActualiza el archivo App.js en la carpeta “src” con el siguiente contenido:\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport NavBar from './components/NavBar';\nimport ListaPublicaciones from './components/ListaPublicaciones';\nimport CrearPublicacion from './components/CrearPublicacion';\nimport DetallePublicacion from './components/DetallePublicacion';\nimport ActualizarPublicacion from './components/ActualizarPublicacion';\nimport EliminarPublicacion from './components/EliminarPublicacion';\n\nconst App = () =&gt; {\n  return (\n    &lt;Router&gt;\n      &lt;div&gt;\n        &lt;NavBar /&gt;\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;ListaPublicaciones /&gt;} /&gt;\n          &lt;Route path=\"/crear\" element={&lt;CrearPublicacion /&gt;} /&gt;\n          &lt;Route path=\"/publicaciones/:id\" element={&lt;DetallePublicacion /&gt;} /&gt;\n          &lt;Route path=\"/publicaciones/:id/actualizar\" element={&lt;ActualizarPublicacion /&gt;} /&gt;\n          &lt;Route path=\"/publicaciones/:id/eliminar\" element={&lt;EliminarPublicacion /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/Router&gt;\n  );\n};\n\nexport default App;\nPaso 11: Estilos CSS con los archivos index.css y App.css\nEn una aplicación React, los estilos CSS se aplican a los componentes para mejorar la apariencia y el diseño de la interfaz de usuario. Por defecto, React crea dos archivos para estilos: index.css y App.css.\nindex.css: Este archivo contiene estilos globales que se aplican a toda la aplicación.\nApp.css: Este archivo contiene estilos específicos para el componente principal de la aplicación (en este caso, el componente App.js).\nA continuación, se muestra cómo puedes usar estos archivos CSS en tu aplicación React:\n\n1. index.css\nEn el directorio src, crea un archivo llamado index.css y agrega los estilos globales que deseas aplicar a toda la aplicación. Por ejemplo:\n/* index.css */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  padding: 0;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n\n\n2. App.css\nEn el directorio src, ya deberías tener un archivo llamado App.css. Puedes agregar estilos específicos para el componente App.js aquí. Por ejemplo:\n/* App.css */\n.header {\n  background-color: #007bff;\n  color: #ffffff;\n  padding: 1rem;\n  text-align: center;\n}\n\n.nav-link {\n  color: #ffffff;\n  text-decoration: none;\n  margin-right: 1rem;\n}\n\n.nav-link:hover {\n  color: #0056b3;\n}\n\n\n3. Importar los archivos CSS en App.js\nEn el componente App.js, importa los archivos CSS para que los estilos se apliquen a la aplicación. Debes importar index.css al principio del archivo src/index.js, y App.css en App.js:\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css'; // Importar index.css aquí\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;App /&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById('root')\n);\n// src/App.js\nimport React from 'react';\nimport './App.css'; // Importar App.css aquí\n\nfunction App() {\n  // Código de la aplicación\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;header className=\"header\"&gt;\n        &lt;nav&gt;\n          &lt;a className=\"nav-link\" href=\"/\"&gt;Home&lt;/a&gt;\n          &lt;a className=\"nav-link\" href=\"/contacto\"&gt;Contacto&lt;/a&gt;\n          &lt;a className=\"nav-link\" href=\"/quienes_somos\"&gt;Quienes Somos&lt;/a&gt;\n          &lt;a className=\"nav-link\" href=\"/crear_publicacion\"&gt;Crear&lt;/a&gt;\n        &lt;/nav&gt;\n      &lt;/header&gt;\n      {/* Resto del contenido de la aplicación */}\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\nCon esto, tus estilos CSS definidos en index.css se aplicarán a toda la aplicación, y los estilos definidos en App.css se aplicarán específicamente al componente App.js. Recuerda adaptar los estilos a tus necesidades y preferencias.\nPaso 12: Importar estilos CSS\nEn el archivo index.js en la carpeta “src”, importa el archivo styles.css para aplicar los estilos personalizados:\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &lt;App /&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById('root')\n);\n\nreportWebVitals();\nCon esto, has creado un proyecto de React independiente que consume los datos de la API creada con Django Rest Framework. Puedes ejecutar el proyecto de React con el siguiente comando:\nnpm start\nLuego, podrás ver la aplicación en el navegador accediendo a http://localhost:3000/.\nLos componentes ListaPublicaciones, CrearPublicacion, ActualizarPublicacion y EliminarPublicacion estarán disponibles en sus respectivas rutas y consumirán datos de la API de Django."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#inconvenientes",
    "href": "unidades/unidad3/unidad3.html#inconvenientes",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Inconvenientes",
    "text": "Inconvenientes\nEn caso de tener inconvenientes con las peticiones por parte de la aplicacion de React, se debe agregar la siguiente linea en el archivo settings.py de la carpeta “backend”:\nCORS_ORIGIN_ALLOW_ALL = True"
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#fundamentos-de-docker.",
    "href": "unidades/unidad5/unidad5.html#fundamentos-de-docker.",
    "title": "Módulo 5:Docker.",
    "section": "Fundamentos de Docker.",
    "text": "Fundamentos de Docker.\n\n\n\n\n\n\n¿Qué es Docker?\nDocker es una tecnología que se ha convertido en el estandar para desarrollar, distribuir y ejecutar aplicaciones a nivel productivo en todo el mundo, en la nube, un nuestras máquinas, es decir en todos lados.\n\n\n¿Por qué utilizar Docker?\n\n\n\n\n\n\n\nImaginemos un proyecto en el que muchas personas (decenas de miles) puedan colaborar en una especie de pizarra digital para compartir nuestras ideas y colaborar, para poder escalar a cientos de miles o millones de usuarios existen muchos desafíos, esto se refiere a lo que sucede con el software cuando lo escribimos en nuestras máquinas y lo que debe hacer cuando este en los dispositivos, los servidores, la nube, etc.\nEstos son los problemas a los que nos enfrenteamos los desarrolladores en todo el mundo, sin importar el lenguaje de programación, framework, base de datos o servidor que utilicemos.\nDocker nos permite resolver este tipo de problemas triviales de forma sencilla, rápida y eficiente. Ayuda a trabajar de forma rápida, mejor con mayor confianza y seguridad."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#problemas-que-están-presentes-en-el-desarrollo-de-software.",
    "href": "unidades/unidad5/unidad5.html#problemas-que-están-presentes-en-el-desarrollo-de-software.",
    "title": "Módulo 5:Docker.",
    "section": "Problemas que están presentes en el Desarrollo de Software.",
    "text": "Problemas que están presentes en el Desarrollo de Software.\n\n\n\n\n\n\n\n\nConstruir: Necesitamos saber como se construye el software que estamos desarrollando.\nDistribuir: Como se va a distribuir a los usuarios que van a utilizar el software\nEjecutar: Como va a funcionar el sofware que hemos desarrollado.\n\n1. Construir.- Escribir código en la máquina del desarrollador. (Compile, que no compile, arreglar el bug, compartir código, etc. )\nProblemática:\n\nEntorno de desarrollo (paquetes)\nDependencias (Frameworks, bibliotecas)\nVersiones de entornos de ejecución (runtime, versión Node)\nEquivalencia de entornos de desarrollo (compartir el código)\nEquivalencia con entornos productivos (pasar a producción)\nServicios externos (integración con otros servicios ej: Base de Datos)\n\n2. Distribuir.- Llevar la aplicación donde se va a desplegar (Transformarse en un artefacto).\nProblemática:\n\nOutput de build heterogeneo (múltiples compilaciones)\nAcceso a servidores productivos (No tenemos acceso al servidor)\nEjecución nativa vs virtualizada\nEntornos Serverless\n\n3. Ejecutar.- Implementar la solución en el ambiente de producción (Subir a producción).\nHacer que funcione como debería funcionar.\nProblemática:\n\nDependencia de aplicación (paquetes, runtime)\nCompatibilidad con el entorno productivo (sistema operativo poco amigable con la solución)\nDisponibilidad de servicios externos (Acceso a los servicios externos)\nRecursos de hardware (Capacidad de ejecución - Menos memoria, procesador más debil)."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#maquinas-virtuales-vs-docker.",
    "href": "unidades/unidad5/unidad5.html#maquinas-virtuales-vs-docker.",
    "title": "Módulo 5:Docker.",
    "section": "Maquinas Virtuales vs Docker.",
    "text": "Maquinas Virtuales vs Docker.\n\n\n\n\n\n\n\n\nVirtualización\nVersion virtual de algún recurso tecnológico, como un servidor, un dispositivo de almacenamiento, un sistema operativo o recurso de red.\nLa virtualización resuelve los tres problemas de la sección anterior.\n\n\nMáquinas Virtuales.\n\n\n\n\n\n\n\n\n\nProblemas de las VMs\nPeso:\n\nEn el orden de los Gb. Repiten archivos en común.\nInicio Lento\n\nCosto de administración:\n\nNecesita mantenimiento igual que cualquier otra comptuadora.\n\nMúltiples formatos.\n\nVDI, VMDK, VHD, raw, entre otros.\n\n\n\nContenedores.\n\n\n\n\n\n\n\n¿Qué es un contenedor?\n\nEs una agrupación de procesos.\nEs una entidad lógica, no tiene el limite estricto de las máquinas virtuales, emulación del sistema operativo simulado por otra más abajo.\nEjecuta sus procesos de forma nativa.\nLos procesos que se ejecutan adentro de los contenedores ven su universo como el contenedor lo define, no pueden ver mas allá del contenedor, a pesar de estar corriendo en una maquina más grande.\nNo tienen forma de consumir más recursos que los que se les permite. Si esta restringido en memoria ram por ejemplo, es la única que pueden usar.\nA fines prácticos los podemos imaginar cómo maquinas virtuales, pero NO lo son. Máquinas virtuales livianas.\nDocker corre de forma nativa solo en Linux.\nSector del disco: Cuando un contenedor es ejecutado, el daemon de docker le dice, a partir de acá para arriba este disco es tuyo, pero no puedes subir mas arriba.\nDocker hace que los procesos adentro de un contenedor este aislados del resto del sistema, no le permite ver más allá.\nCada contenedor tiene un ID único, también tiene un nombre.\n\n\n\nContainerización.\nEmpleo de contenedores para construir y desplegar software.\nCaracteristicas.\n\nFlexibles\nLivianos\nPortables\nBajo acoplamiento\nEscalables\nSeguros"
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#arquitectura-de-docker.",
    "href": "unidades/unidad5/unidad5.html#arquitectura-de-docker.",
    "title": "Módulo 5:Docker.",
    "section": "Arquitectura de Docker.",
    "text": "Arquitectura de Docker.\n\n\n\n\n\n\n\nDocker es una Plataforma que permite construir, ejecutar y compartir aplicaciones mediante contenedores.\nContainer: Es una instancia de una imagen.\nImage: Es un paquete de software que incluye todo lo necesario para ejecutar una aplicación.\nNetwork: Es una red virtual que permite la comunicación entre contenedores y con el exterior.\nData Volumes: Es un directorio que se monta en un contenedor para que este pueda acceder a el."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#trabajar-con-docker.",
    "href": "unidades/unidad5/unidad5.html#trabajar-con-docker.",
    "title": "Módulo 5:Docker.",
    "section": "Trabajar con Docker.",
    "text": "Trabajar con Docker.\nPaso 1: Instalar Docker\nLo primero que debemos hacer es instalar Docker en nuestro sistema operativo. Para ello, visita el sitio web oficial de Docker y sigue las instrucciones de instalación para tu sistema operativo específico.\nPaso 2: Verificar la Instalación\nUna vez instalado Docker, verifica que esté funcionando correctamente ejecutando el siguiente comando:\ndocker --version \nEste comando mostrará la versión de Docker instalada en tu sistema.\nAhora empecemos a probar Docker.\ndocker run hello-world\nEste comando descargará la imagen de Docker hello-world y la ejecutará en un contenedor. Cuando el contenedor se ejecute, imprimirá un mensaje y saldrá.\nPaso 3: Descargar una Imagen de Docker\nDocker utiliza imágenes para crear contenedores. Una imagen es una plantilla de solo lectura que contiene el sistema operativo, el software y los archivos necesarios para ejecutar una aplicación. Puedes descargar imágenes de Docker Hub, que es un registro de imágenes públicas disponibles para su uso.\nPara descargar una imagen, utiliza el siguiente comando:\ndocker pull nombre_de_la_imagen \nPor ejemplo, para descargar la imagen oficial de Ubuntu, puedes ejecutar:\ndocker pull ubuntu \nPaso 4: Ver Imágenes Descargadas\nPara ver la lista de imágenes descargadas en tu sistema, puedes utilizar el siguiente comando:\ndocker images \nPaso 5: Crear un Contenedor\nUna vez que tengas una imagen descargada, puedes crear un contenedor basado en esa imagen. Para ello, utiliza el siguiente comando:\ndocker run nombre_de_la_imagen \nPor ejemplo, para crear un contenedor basado en la imagen de Ubuntu, puedes ejecutar:\ndocker run ubuntu \nPaso 6: Ver Contenedores en Ejecución\nPara ver la lista de contenedores en ejecución en tu sistema, puedes utilizar el siguiente comando:\ndocker ps \nPaso 7: Ver Todos los Contenedores\nPara ver la lista de todos los contenedores, incluidos los que no están en ejecución, puedes utilizar el siguiente comando:\ndocker ps -a \nAhora probemos el docker id con el comando inxpect.\ndocker inspect ID_del_contenedor \nCon este comando vemos toda la información del contenedor.\nAhora probemos dar un NAME al contenedor.\ndocker run --name nombre_del_contenedor nombre_de_la_imagen \nMuy bien, por favor hagamos una pequeña práctica para probar lo que hemos aprendido, por favor creemos 10 contenedores con nombres de paises, por ejemplo: Colombia, Argentina, Brasil, Chile, Ecuador, España, Francia, Italia, México, Perú.\ndocker run --name Colombia hello-world\ndocker run --name Argentina hello-world\ndocker run --name Brasil hello-world\ndocker run --name Chile hello-world\n'''etc'''\nAhora probemos el comando inxpect con el nombre del contenedor.\ndocker inspect nombre_del_contenedor \nPaso 8: Detener un Contenedor\nPara detener un contenedor en ejecución, puedes utilizar el siguiente comando:\ndocker stop ID_del_contenedor \nReemplaza ID_del_contenedor con el ID real del contenedor que deseas detener.\nPaso 9: Eliminar un Contenedor\nAntes de continuar probemos el comando docker container prune, este comando elimina todos los contenedores que no estén en ejecución.\ndocker container prune \nPara eliminar un contenedor que no está en ejecución, puedes utilizar el siguiente comando:\ndocker rm ID_del_contenedor \nReemplaza ID_del_contenedor con el ID real del contenedor que deseas eliminar."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#docker-desde-visual-studio-code.",
    "href": "unidades/unidad5/unidad5.html#docker-desde-visual-studio-code.",
    "title": "Módulo 5:Docker.",
    "section": "Docker desde Visual Studio Code.",
    "text": "Docker desde Visual Studio Code.\nlos pasos para instalar la extensión de Docker en Visual Studio Code y cómo utilizarla para trabajar con Docker en tu proyecto.\nPaso 1: Instalar la extensión de Docker para Visual Studio Code\nAbre Visual Studio Code.\nHaz clic en el icono de extensiones en el panel lateral izquierdo o presiona Ctrl+Shift+X (o Cmd+Shift+X en macOS) para abrir la sección de extensiones.\nEn el cuadro de búsqueda, escribe “Docker” y selecciona la extensión “Docker” desarrollada por Microsoft.\nHaz clic en el botón “Instalar” para instalar la extensión.\nUna vez instalada, verás un nuevo icono de Docker en la barra lateral izquierda de VS Code.\nPaso 2: Utilizar la extensión de Docker en tu proyecto\nUna vez que la extensión de Docker está instalada, puedes utilizarla para gestionar imágenes y contenedores de Docker en tu proyecto.\nAbre la carpeta de tu proyecto en Visual Studio Code.\nHaz clic en el icono de Docker en la barra lateral izquierda para abrir la vista de Docker.\nEn la vista de Docker, verás diferentes secciones como “Imagenes”, “Contenedores”, “Volúmenes” y “Redes”.\nPara construir una imagen de Docker para tu proyecto, haz clic con el botón derecho en la carpeta raíz de tu proyecto y selecciona “Build Image…” en el menú contextual. Esto abrirá una ventana donde puedes configurar los detalles de la imagen y su etiqueta.\nPara crear y ejecutar un contenedor basado en la imagen que acabas de construir, haz clic con el botón derecho en la imagen en la sección “Imagenes” y selecciona “Run”. Esto abrirá una ventana donde puedes configurar las opciones del contenedor, como los puertos y las variables de entorno.\nUna vez que el contenedor esté en ejecución, puedes ver sus registros y otros detalles haciendo clic en el contenedor en la sección “Contenedores”.\nPuedes detener y eliminar contenedores desde la vista de Docker haciendo clic con el botón derecho en el contenedor y seleccionando “Stop” o “Remove”.\nEstos son algunos de los pasos básicos para utilizar Docker desde Visual Studio Code con la extensión oficial de Docker.\nLa extensión proporciona una forma sencilla de gestionar imágenes y contenedores de Docker directamente desde el entorno de desarrollo de VS Code, lo que facilita el trabajo con Docker en tus proyectos.\nPráctica: Dockerizar el Proyecto Django “Blog”\nA continuación, vamos a dockerizar el proyecto Django Blog que hemos estado desarrollando. Para ello, vamos a seguir los siguientes pasos:\n\nCrear un archivo Dockerfile en el directorio raíz del proyecto.\n\nEste archivo contendrá las instrucciones para construir la imagen de Docker.\n\nEn el Dockerfile, especificar la imagen base que utilizaremos.\n\nPor ejemplo, podemos usar la imagen oficial de Python para Django:\nFROM python:3.8 \n\nCopiar el código fuente de nuestra aplicación al contenedor:\n\nCOPY . /app \n\nEstablecer el directorio de trabajo dentro del contenedor:\n\nWORKDIR /app \n\nInstalar las dependencias de Python necesarias para nuestro proyecto:\n\nRUN pip install -r requirements.txt \n\nExponer el puerto en el que se ejecutará nuestro servidor de Django:\n\nEXPOSE 8000 \n\nEspecificar el comando para ejecutar nuestra aplicación:\n\nCMD [\"python\", \"manage.py\", \"runserver\", \"0.0.0.0:8000\"] \n\nGuardar y cerrar el archivo Dockerfile.\nDesde la línea de comandos, navegar al directorio raíz del proyecto y ejecutar el siguiente comando para construir la imagen de Docker:\n\ndocker build -t nombre_de_la_imagen . \nReemplaza nombre_de_la_imagen con un nombre significativo para tu imagen.\n\nUna vez que la imagen se haya construido correctamente, puedes crear un contenedor basado en esa imagen:\n\ndocker run -p 8000:8000 nombre_de_la_imagen \nReemplaza nombre_de_la_imagen con el nombre de la imagen que creaste en el paso anterior.\n\nAhora, deberías poder acceder a tu aplicación Django desde tu navegador ingresando http://localhost:8000.\n\nCon estos pasos, habrás dockerizado exitosamente tu proyecto Django Blog y estará listo para ser desplegado en cualquier entorno que tenga Docker instalado."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#introducción-a-docker-compose",
    "href": "unidades/unidad5/unidad5.html#introducción-a-docker-compose",
    "title": "Módulo 5:Docker.",
    "section": "Introducción a Docker Compose",
    "text": "Introducción a Docker Compose\nDocker Compose es una herramienta que permite definir y gestionar aplicaciones multi-contenedor. Permite definir las dependencias, servicios, redes y volúmenes que componen una aplicación en un archivo YAML, lo que facilita la configuración y el despliegue de la aplicación en diferentes entornos.\nA diferencia de Docker, que se enfoca en la construcción y ejecución de contenedores individuales, Docker Compose se centra en la orquestación de múltiples contenedores y su interacción."
  },
  {
    "objectID": "unidades/unidad5/unidad5.html#ventajas-de-usar-docker-compose",
    "href": "unidades/unidad5/unidad5.html#ventajas-de-usar-docker-compose",
    "title": "Módulo 5:Docker.",
    "section": "Ventajas de usar Docker Compose",
    "text": "Ventajas de usar Docker Compose\nDefinición clara de servicios: Con Docker Compose, podemos definir todos los servicios necesarios para nuestra aplicación en un solo archivo YAML, lo que facilita la gestión de la infraestructura de la aplicación.\nConfiguración simplificada: Docker Compose permite establecer todas las configuraciones necesarias para cada servicio en un solo lugar, lo que facilita la gestión de la configuración y el despliegue en diferentes entornos.\nInterconexión de servicios: Docker Compose facilita la conexión de diferentes servicios y la comunicación entre ellos, lo que es especialmente útil para aplicaciones que requieren una arquitectura de microservicios.\nEscalabilidad: Docker Compose permite escalar servicios individuales según las necesidades de la aplicación, lo que facilita el escalado horizontal de la aplicación.\n\nCómo usar Docker Compose en nuestro proyecto Django “Blog”\nPara utilizar Docker Compose en nuestro proyecto Django Blog, seguiremos los siguientes pasos:\n\nCrear un archivo docker-compose.yml en el directorio raíz del proyecto.\nEste archivo contendrá la configuración de los servicios y contenedores de nuestra aplicación.\n\nEn el archivo docker-compose.yml, definir los servicios necesarios para nuestra aplicación. Por ejemplo, podemos definir dos servicios: uno para el servidor de Django y otro para la base de datos.\nversion: '3'\n\nservices:\n  db:\n    image: postgres\n    environment:\n      POSTGRES_DB: blog\n      POSTGRES_USER: myuser\n      POSTGRES_PASSWORD: mypassword\n\n  web:\n    build: .\n    command: python manage.py runserver 0.0.0.0:8000\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - db\nGuardar y cerrar el archivo docker-compose.yml.\nDesde la línea de comandos, navegar al directorio raíz del proyecto y ejecutar el siguiente comando para construir las imágenes de los servicios definidos en el archivo docker-compose.yml:\ndocker-compose build\nUna vez que las imágenes se hayan construido correctamente, puedes ejecutar el siguiente comando para iniciar los contenedores definidos en el archivo docker-compose.yml:\ndocker-compose up\nAhora, deberías poder acceder a tu aplicación Django desde tu navegador ingresando http://localhost:8000.\nCon estos pasos, habrás utilizado Docker Compose para gestionar los servicios y contenedores de tu aplicación Django “Blog”. Docker Compose simplifica el despliegue y la gestión de aplicaciones multi-contenedor, lo que lo convierte en una herramienta muy útil para el desarrollo de aplicaciones complejas y escalables."
  },
  {
    "objectID": "about.html#nuestro-objetivo",
    "href": "about.html#nuestro-objetivo",
    "title": "Acerca de Nosotros",
    "section": "Nuestro Objetivo",
    "text": "Nuestro Objetivo\nNuestro objetivo es proporcionarte los conocimientos y las habilidades necesarias para comenzar a programar utilizando Python. Queremos que te sientas cómodo con los conceptos básicos y que estés preparado para abordar proyectos más desafiantes en el futuro."
  },
  {
    "objectID": "about.html#nuestro-equipo",
    "href": "about.html#nuestro-equipo",
    "title": "Acerca de Nosotros",
    "section": "Nuestro Equipo",
    "text": "Nuestro Equipo\nNuestro equipo está formado por apasionados desarrolladores y educadores que tienen una amplia experiencia en el mundo de la programación. Estamos aquí para ayudarte en cada paso del camino y responder a tus preguntas."
  },
  {
    "objectID": "about.html#contacto",
    "href": "about.html#contacto",
    "title": "Acerca de Nosotros",
    "section": "Contacto",
    "text": "Contacto\nSi tienes preguntas, comentarios o sugerencias, no dudes en ponerte en contacto con nosotros a través de nuestro correo electrónico o redes sociales.\n¡Esperamos que disfrutes aprendiendo con nosotros!"
  },
  {
    "objectID": "license.html#uso-permitido",
    "href": "license.html#uso-permitido",
    "title": "Licencia",
    "section": "Uso Permitido",
    "text": "Uso Permitido\nPuedes utilizar el contenido de este curso con fines educativos y personales. Puedes modificar los ejemplos y el código proporcionado para tus propias necesidades de aprendizaje."
  },
  {
    "objectID": "license.html#restricciones",
    "href": "license.html#restricciones",
    "title": "Licencia",
    "section": "Restricciones",
    "text": "Restricciones\nNo tienes permitido redistribuir, vender o utilizar el contenido de este curso para fines comerciales sin el permiso explícito de [Nombre de la Compañía]. Además, no tienes permitido copiar o duplicar el contenido del curso y presentarlo como propio."
  },
  {
    "objectID": "license.html#atribución",
    "href": "license.html#atribución",
    "title": "Licencia",
    "section": "Atribución",
    "text": "Atribución\nSi compartes los ejemplos, los fragmentos de código o el contenido de este curso en línea, te pedimos que proporciones la atribución adecuada a [Nombre de la Compañía]."
  },
  {
    "objectID": "license.html#cambios-en-la-licencia",
    "href": "license.html#cambios-en-la-licencia",
    "title": "Licencia",
    "section": "Cambios en la Licencia",
    "text": "Cambios en la Licencia\n[Nombre de la Compañía] se reserva el derecho de modificar los términos de esta licencia en cualquier momento. Cualquier cambio se reflejará en esta página.\nGracias por respetar nuestros derechos de autor y por tu comprensión."
  },
  {
    "objectID": "index.html#bienvenida",
    "href": "index.html#bienvenida",
    "title": "Django 2023",
    "section": "Bienvenida",
    "text": "Bienvenida\n\n\n\n¡Bienvenidos al Curso Completo de Django! Este libro te guiará a través de un viaje desde los fundamentos hasta la creación de un blog funcional utilizando el framework de desarrollo web Django en Python."
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#estructura-de-directorios-generada",
    "href": "unidades/unidad1/unidad1.html#estructura-de-directorios-generada",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Estructura de directorios generada:",
    "text": "Estructura de directorios generada:\nnombre_proyecto/\n    manage.py\n        __init__.py\n        settings.py\n        urls.py\n        asgi.py\n        wsgi.py"
  },
  {
    "objectID": "unidades/unidad1/unidad1.html#estructura-de-directorios-de-un-proyecto-django.",
    "href": "unidades/unidad1/unidad1.html#estructura-de-directorios-de-un-proyecto-django.",
    "title": "Módulo 1: Introducción a Django.",
    "section": "Estructura de Directorios de un Proyecto Django.",
    "text": "Estructura de Directorios de un Proyecto Django.\nLa estructura de directorios de un proyecto Django se organiza de la siguiente manera:\n\nnombre_proyecto/\n│   manage.py\n│\n└───nombre_proyecto/\n│   │   __init__.py\n│   │   settings.py\n│   │   urls.py\n│   │   asgi.py\n│   │   wsgi.py\n│\n└───otras_aplicaciones/\n    │   ...\n\nnombre_proyecto/: Es el directorio raíz del proyecto. Contiene el archivo “manage.py”, una herramienta para administrar y ejecutar comandos de Django.\nnombre_proyecto/nombre_proyecto/: Este directorio es la configuración principal del proyecto. Contiene varios archivos esenciales, entre ellos:\n\ninit.py: Indica que el directorio es un paquete y permite la importación de módulos dentro de él.\nsettings.py: Aquí se encuentran todas las configuraciones del proyecto, como bases de datos, aplicaciones instaladas, rutas de plantillas, configuraciones de seguridad, etc.\nurls.py: Contiene las configuraciones de las URLs del proyecto, es decir, cómo se manejan las solicitudes y se mapean a las vistas.\nasgi.py y wsgi.py: Son archivos de configuración para el servidor ASGI (Asynchronous Server Gateway Interface) y WSGI (Web Server Gateway Interface), respectivamente. Estos archivos son utilizados por servidores web para servir la aplicación Django.\n\notras_aplicaciones/: Este directorio es opcional y se utiliza para organizar aplicaciones adicionales desarrolladas para el proyecto. Cada aplicación puede tener su propia estructura de directorios."
  },
  {
    "objectID": "unidades/unidad3/unidad3.html#configuración-del-proyecto-django",
    "href": "unidades/unidad3/unidad3.html#configuración-del-proyecto-django",
    "title": "Módulo 3: Vistas y Plantillas.",
    "section": "Configuración del Proyecto Django",
    "text": "Configuración del Proyecto Django\nPrimero, asegúrate de tener Django instalado:\npip install django\nLuego, crea un nuevo proyecto y una aplicación dentro de ese proyecto:\ndjango-admin startproject myblog\ncd myblog\npython manage.py startapp blog\n\nDefinir Modelos y Configurar la Base de Datos\n\nEn el archivo blog/models.py, define un modelo simple para las publicaciones del blog:\nfrom django.db import models\n\nclass Post(models.Model):\n    title = models.CharField(max_length=200)\n    content = models.TextField()\n    date_posted = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.title\nNo olvides agregar ‘blog’ a la lista de INSTALLED_APPS en myblog/settings.py.\nAplica las migraciones para crear la base de datos:\npython manage.py makemigrations\npython manage.py migrate\n\nCrear Vistas y Plantillas\n\nEn blog/views.py, crea una vista para mostrar las publicaciones del blog:\nfrom django.shortcuts import render\nfrom .models import Post\n\ndef home(request):\n    posts = Post.objects.all()\n    return render(request, 'blog/home.html', {'posts': posts})\nCrea el archivo de plantilla blog/templates/blog/home.html:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;My Blog&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: 'Arial', sans-serif;\n            background-color: #f2f2f2;\n            margin: 0;\n            padding: 0;\n        }\n\n        .navbar {\n            background-color: #333;\n            padding: 15px;\n            color: white;\n            text-align: center;\n        }\n\n        .content {\n            padding: 20px;\n        }\n\n        .footer {\n            background-color: #333;\n            color: white;\n            text-align: center;\n            padding: 10px;\n            position: fixed;\n            bottom: 0;\n            width: 100%;\n        }\n\n        .post {\n            background-color: #fff;\n            padding: 15px;\n            margin: 15px 0;\n            border-radius: 5px;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div class=\"navbar\"&gt;\n    &lt;h2&gt;My Blog&lt;/h2&gt;\n&lt;/div&gt;\n\n&lt;div class=\"content\"&gt;\n    {% for post in posts %}\n        &lt;div class=\"post\"&gt;\n            &lt;h2&gt;{{ post.title }}&lt;/h2&gt;\n            &lt;p&gt;{{ post.content }}&lt;/p&gt;\n            &lt;p&gt;Posted on: {{ post.date_posted }}&lt;/p&gt;\n        &lt;/div&gt;\n    {% endfor %}\n&lt;/div&gt;\n\n&lt;div class=\"footer\"&gt;\n    &lt;p&gt;&copy; 2023 My Blog. All rights reserved.&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\nConfigurar URLs\n\nEn blog/urls.py, define las URLs para tu aplicación:\nfrom django.urls import path\nfrom .views import home\n\nurlpatterns = [\n    path('', home, name='blog-home'),\n]\nIncluye estas URLs en el archivo myblog/urls.py:\nfrom django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('blog.urls')),\n]\n\nEjecutar la Aplicación\n\nFinalmente, ejecuta tu aplicación Django:\npython manage.py runserver\nVisita http://localhost:8000 en tu navegador y deberías ver tu blog con un Navbar, la visualización de publicaciones y un Footer, todo con un diseño atractivo."
  }
]